                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            [{"title":"Mac快捷键","date":"2019-11-08T06:26:02.000Z","url":"/Mac快捷键.html","tags":["杂谈低语"],"content":"Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的官方文档里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。这些快捷键在 Mac 里面是通用的，也就意味着在几乎所有的有文本输入的地方，都可以用得上，一次学习，使用Anywhere :)。要熟悉掌握这些组合，还是要下一定功夫勤加练习的，不然右手又会不自觉地去触摸鼠标了。不过还是有一定技巧的，主要是掌握 ctl、shift、fn 的组合而已。（强烈建议大家将键盘上的大小写切换键改为 ctl 键，因为 ctl 的作用远比大小写切换重要多了，大小写切换完全可以使用 shift + 字母的方式进行输入，但大小写键在键盘上却占据了很重要的位置，ctl缩在角落瑟瑟发抖）。修改方法：系统设置 -&gt; 键盘 -&gt; 修饰键（在右下角）-&gt; 大写锁定键改为 Control光标移动cmd + ←      移动至行首cmd + →      移动至行尾fn + ↓        向下翻页fn + ↑        向上翻页option + ←    向前跳一个词option + →     向后跳一个词ctl + p     光标向上移动一行ctl + n     光标向下移动一行ctl + b     光标向前移动一个字母ctl + f      光标向后移动一个字母ctl + e      光标移动到行尾ctl + a      光标移动到行首选取option + shift + ←     向前选中一个单词option + shift + →     向后选中一个单词cmd + shift + →        从当前光标选中到行尾cmd + shift + ←         从当前光标选中到行首删除fn + delete      向后删除option + delete     向前删除一个单词fn + option + delete     向后删除一个单词cmd + delete     从当前光标删除到行首fn + cmd + delete     从当前光标删除到行尾Snap最后，也推荐给大家一个软件 Snap，在 AppStore 可以直接下载。这个软件的作用是绑定应用快捷键的，可以把对应的应用绑定成自己喜欢的快捷键，通过快捷键快速启动和切换应用，时间复杂度是 O(1)，远比用 cmd + tab（时间复杂度 O(n)）或者用鼠标点击（时间复杂度 O(n^2)）快多了软件主界面长这样：这个主要是设置默认快捷键的，比如这里设置了 ctl + cmd，那么你就可以通过 ctl + cmd + 1  的快捷键来启动或者切换 Dock 上的第一个应用，ctl + cmd + 2 启动或者切换第二个，以此类推。上面这种方法不是很建议，因为需要记住应用在 Dock 上的位置或者自己手动排列 Dock 位置。还有另外一种方法就是 Manual，就是上面说的应用绑定快捷键，界面长这样：点击左下角就可以选择一个应用，然后输入对应的快捷键，后面就可以愉快的玩耍了 ^-^"},{"title":"What's New in Xcode11","date":"2019-11-05T07:38:21.000Z","url":"/What-s-New-in-Xcode11.html","tags":["iOS"],"content":"WWDC19 - What’s New in Xcode11WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 WWDC 2019 Session 401，顺便做一下记录。首先，对 Xcode11 的整体改进做一个预览：整体的改变还是挺多的，下面一一对改进的功能进行说明。右上角功能键的改进首先，Xcode 11 改变的是右上角的按钮，Xcode 10 上是三个按钮，到了 11 已经变成了两个按钮：                  原先的 Source Control Log 被移到了右侧栏里面：             原先的比较常用的切换 Assitant Editor 和 Authors 一起并入到了 Editor Options 里面，并将 Editor Options 移到了每个独立的编辑窗口里面：                                 上面 Xcode 11 的 Assistant 就是原先 Xcode 10 右上角的那两个圈圈Editor Options 中同时新增了一个 Swift UI 的预览，当项目中使用到了 Swfit UI 的时候，可以预览 Swift UI 的效果现在 Xcode 11 上面的两个按钮的功能变成了 Library 和 Code Review：Library 的主要功能是：选择 IB 控件、文档、代码块、图片资源以及颜色Code Review 的主要功能是：比较同一源文件源码的改动Editor Splitting在 Xcode 11 里面，增加了一个 Editor Spliting 的功能，可以随时随地的增加一个 Editor：Editor Spliting 默认的是往右边增加，按住 option 键再点击这个按钮，就可以在下面增加新的 Editor可以通过按住 shift + option 并点击源文件，来管理 Editor，点击的源文件那个窗口会变成选中效果，可以用鼠标或者键盘方向键进行移动，移动完成后，点击键盘上的 return，原先选中的源文件就会插入或者移动到当前位置MinimapXcode 11 比较大的一个改动就是新增了 Minimap：Minimap 主要是提供导航作用的，点击 Minimap 的任意位置，源码便会滚动到点击的地方。 当鼠标悬停在上面时，会显示当前的方法名：同时按住 cmd 键的话，会显示当前所有的方法名：当源码中有 warning 或者断点时，在 Minimap 中也会显示源码中的 marks 在 Minimap 里可以直接看到：当在源码中搜索关键字时，所有符合条件的在 Minimap 中会有选中效果：源码 EditorXcode 11 中通过 cmd + 右键点击方法名，可以给方法添加参数注释。新增了参数时，通过这个方法会自动拼接新的参数：cmd + 右键点击参数，选择 Edit All in Scope，可以同时修改方法名、方法内、注释里面的参数名称：当对源码进行了修改时，在 Editor 的左侧会出现一个蓝色条，点击这个蓝色条，可以选择 Show Change 和 Discard Change。Discard Change 的作用是撤销修改，Show Change 的作用是显示哪些地方进行了改动：除此之外，Xcode 11 还有着更好的自动补全、增加了新的 Theme，优化了一些细节体验"},{"title":"Cordova in iOS","date":"2016-09-07T16:00:00.000Z","url":"/Cordova.html","tags":["Cordova"],"categories":["Cordova"],"content":"Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。环境搭建安装Cordova:第一个参数为工程文件夹第二个参数为应用的的 id 名，和 Xcode 中的 bundle Id 类似第三个参数为工程名字添加 iOS 平台支持进入刚刚创建的工程目录下，执行：执行这个命令只出现光标没有反应的话，是因为网络原因。由于国内的网络环境，虽然的 npm 官方站点  并没有被墙，但是下载第三方依赖包的速度有时还是不理想，我们可以改用淘宝的 NPM 镜像。打开 ~/.npmrc 文件：添加以下内容：保存退出，再执行命令就会发现很快就配置好了。打开 platforms/ios 目录，就可以运行我们的创建的工程了。"},{"title":"OpenGL实战(一) - 简单图形绘制","date":"2016-08-30T16:00:00.000Z","url":"/OpenGLES-2.html","tags":["OpenGL ES"],"categories":["OpenGL ES"],"content":"在上一篇文章中我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码+知识点+API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我（评论采用disqus，如果加载不出来，翻个墙试一下，联系方式见关于我）。渲染屏幕====首先，将控制器继承自GLKViewController，并初始化一个GLKView，设置为它的View：只需在GLKView的代理方法(void)glkView:(GLKView *)view drawInRect:(CGRect)rect中，调用glClear的系列函数就可以用OpenGL ES对屏幕进行渲染了：现在来做一个酷炫的效果，让屏幕显示闪烁。当设置GLKViewController代理的时候，每一帧动画GLKViewController都会告诉我们，它会在1秒内多次调用draw方法，GLKViewController的代理中，我们可以在GLKViewController的代理方法(void)glkViewControllerUpdate:(GLKViewController *)controller方法来更新屏幕的颜色。首先定义两个参数并初始化:设定GLKViewController的刷新频率:更新(void)glkView:(GLKView *)view drawInRect:(CGRect)rect中的代码，在GLKViewController的代理方法中更新屏幕颜色:这样就实现了屏幕黑红闪烁效果，Demo可以在这里找到。绘制图形现在我们来利用OpenGL ES绘制一个正方形。因为OpenGL ES只能渲染三角形，所以要用两个三角形来组成一个正方形。首先创建一组顶点数据和索引数据：顶点数据中包括了顶点位置和对应的颜色，索引数据则是顶点数组的索引。然后我们需要向OpenGL ES发送数据和缓存数据：关于 usage 的一些说明：GL_STREAM_DRAW: 数据只指定一次，并且最多只有几次作为绘图和指定图像函数的源数据GL_STREAM_READ: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次由应用程序作为数据值使用GL_STREAM_COPY: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次作为绘图和指定图像函数的源数据GL_STATIC_DRAW: 数据只指定一次，但是可以多次几次作为绘图和指定图像函数的源数据GL_STATIC_READ:  数据从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用GL_STATIC_COPY: 数据从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据GL_DYNAMIC_DRAW: 数据可以多次指定，并且可以多次几次作为绘图和指定图像函数的源数据GL_DYNAMIC_READ: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用 GL_DYNAMIC_COPY: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据在OpenGL ES2.0当中，无论渲染什么图形，都必须用到着色器。着色器是用类C语言-GLSL语言写的，如果想要自定义一个着色器，那么学习这门语言十分有必要。现在GLKBaseEffect这个类为我们提供了一些通用的着色器，在还没有掌握GLSL的情况下，我们目前可以使用它来帮我们实现效果：最后在代理方法中启动着色器:这样我们就可以看到最终的效果了：细心观察就会发现，我们想要的结果是一个正方形，现在出来的效果却是一个矩形，这是为什么呢？因为默认的，“Effect”的投影矩阵是一个单位矩阵，它不做任何变换，将场景（-1，-1，-1）到（1，1，1）的立文体范围的物体，投射到屏幕的X：-1，1，Y：-1，1。因此，当屏幕本身是非正方形时，正方形的物体将被拉伸，从而显示为矩形。所以我们要在update 中修改投影矩阵：最终通过这段代码就能得到我们想要的结果了：一个正方形（Demo 在这里）。在学习过程中，踩了很多坑，包括一开始的图像显示不出来，API 的意思也不明确。后来通过 Google 查阅相关资料，把一些 bug 解决了，同时也加深了对 OpenGL ES 的理解，学习到了很多的东西。上面的知识，在代码中我已经注释的很清楚了，如果有不懂的地方或者不正确的地方，欢迎指正交流~"},{"title":"初识 OpenGL ES","date":"2016-08-28T16:00:00.000Z","url":"/OpenGLES-1.html","tags":["OpenGL ES"],"categories":["OpenGL ES"],"content":"在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！什么是OpenGL ESOpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。OpenGL ES是从OpenGL裁剪定制而来的，去除了glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性。经过多年发展，现在主要有两个版本，OpenGL ES 1.x针对固定管线硬件的，OpenGL ES 2.x针对可编程管线硬件。OpenGL ES 1.0是以OpenGL 1.3规范为基础的，OpenGL ES 1.1是以OpenGL 1.5规范为基础的，它们分别又支持common和common lite两种profile。lite profile只支持定点实数，而common profile既支持定点数又支持浮点数。OpenGL ES 2.0则是参照OpenGL 2.0规范定义的，common profile发布于2005-8，引入了对可编程管线的支持。OpenGL ES 3.0于2012年公布，加入了大量新特性。              - - - - 维基百科苹果官方文档中对于OpenGL ES的描述为：OpenGL ES让App拥有了利用底层图形处理器的能力，iOS设备上的GPU可以执行复杂的2D和3D绘图，以及在最终图像上的每个像素的复杂着色计算。OpenGL ES是低级的、以硬件为中心的基于C的API，可以与iOS应用无缝集成。OpenGL ES规范没有定义窗口层，取而代之，当有任何绘图命令写入，主机操作系统必须定义一个方法来创建OpenGL ES渲染上下文，用来接受命令和帧缓冲。OpenGL ES基本概念坐标系由于OpenGL ES可以用来绘制2D和3D图形，所以它的坐标是一个三维坐标，如果应用只涉及到2D，那么可以不考虑Z轴。纹理坐标一般OpenGL ES中的纹理坐标都是二维的，原点在左下角，与计算机中的图像坐标并不一致，二者的差别在于围绕横轴翻转180°。顶点数据&amp;&amp;索引顶点数据是一个数组，里面存的是顶点坐标。而索引则是顶点数组的对应的索引和串联关系。上面顶点数组里面的一行就代表了坐标系里面的x,y,z三个坐标系，代表了一个顶点的位置，里面总共包含了4个点。索引数组则是顶点数据的索引，每一行代表一个连接关系，从0-1-2，从1-3-0。EAGLContext在使用OpenGL ES之前，必须初始化一个EAGLContext对象，并且将它设置为当前上下文注意事项：每个线程都会维护一个当前上下文。设置了一个新的上下文，EAGL会释放当前上下文，并且获取新的上下文。当在同一个线程中转换两个或者更多的上下文时，在设置一个新的上下文作为当前上下文之前，需要调用glFlush函数，确保之前的一些命令可以及时传递给图像硬件设备。调用glFlush函数时需导入OpenGLES/ES2/gl.h框架。GLKViewGLKView介绍GLKView管理着OpenGL ES的基础，来提供绘制代码的地方。GLKView提供了基于OpenGL ES并等效于标准UIView的绘图生命周期。一个UIView实例自动配置图像上下文，所以drawRect:只需执行Quartz 2D绘图命令，GLKView实例自动配置本身，所以你的绘图方法只需执行OpenGL ES命令。GLKView通过维护一个保存着OpenGL ES绘图命令的帧缓冲对象来实现这一功能，一旦你的绘图方法完成，就会自动把结果呈现给Core Animation。GLKView初始化方法GLKViewDelegateGLKView能够为OpenGL ES的绘制提供一个简单的界面，因为它管理着OpenGL ES渲染过程的部分标准：在调用绘图方法之前，视图：使EAGLContext为当前上下文基于当前大小、比例因子和drawable属性（如果需要），创建帧缓冲对象和渲染缓冲区将帧缓冲对象作为绘图命令的当前目标设置OpenGL ES视图端口来匹配帧缓冲区大小绘图方法执行完后，视图：解析多重采样缓冲区（如果允许多重采样）丢弃不需要的渲染缓冲区将渲染缓冲区内容交给Core Animation缓存和显示参考：    OpenGL ES Programming Guide for iOS "},{"title":"iOS 事件拦截","date":"2016-07-19T16:00:00.000Z","url":"/iOSEvent.html","tags":["事件拦截"],"categories":["事件机制"],"content":"在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。iOS事件机制iOS 中的事件分为三类：触摸事件（单点、多点、手势），传感器事件（加速传感器）和远程控制事件（官方文档），我们遇到情况是第一种也就是触摸事件的机制。响应者链当一个事件发生时，如果 first responder 不做处理，那么就会往下传递，如果下一个 responder 也不处理，那么就会继续传递到再下一个 responder 中，直到有一个 responder 处理或者没有 responder 了，如果没有 responder 处理这个事件，那么这个事件就被抛弃了。这些 responder 按照传递顺序连接起来就构成了响应者链。iOS 中的响应者链：从图中我们可以观察到，响应者链有以下几个特点：响应者链通常由 initial view 开始。View 的 nextResponder 是它的 superView，如果 View 已经是它所在的 ViewController 中的 top view，那么 next responder 就是它所在的 ViewConTroller。ViewController 如果有 superViewController，那么它的 nextResponder 就是它superViewController 最上面的 View。如果没有，那么它的 nextResponder 就是 Window。Window 的 nextResponder 指向 Application，Application 是整个响应者链的顶层，它的 nextResponder 指向 nil。也就是说当事件传递到 Application 不被处理的话就会被抛弃了。由于 UI 的复杂性，整个响应者链是需要通过计算的，而计算顺序基本是与响应者链分发相反的。无论哪种事件，都是系统本身先获得，再交给 UIApplication，由 UIApplication 决定交给谁去处理。 关于事件分发的计算网上有很多文章，我就不赘述了。通过上述了解，我们可以得出一个结论：如果我们需要拦截一个事件，最好的机会是在 UIApplication 里面。需求具体实现OC 版根据上面的结论，我们目前的思路是继承 UIApplication，然后实现某一方法，进行事件拦截。根据查阅资料，重写 UIApplication 的 sendEvent方法可以达到目的，sendEvent介绍如下： sendEvent:Dispatches an event to the appropriate responder objects in the application. ParameterseventA UIEvent object encapsulating the information about an event, including the touches involved.DiscussionSubclasses may override this method to intercept incoming events for inspection and special dispatching. iOS calls this method for public events only.具体代码实现：新建一个继承 UIApplication 的 CTApplication，重写 sendEvent 方法，并判断是否为触摸事件：2.由于需要检测用户多长时间没有点击屏幕，需要加一个定时器来进行倒计时，设置定时器的方法写在 CTApplication 的 init 方法中：3.再回到 sendEvent 方法中，如果该方法被触发了，那么让定时器失效，重新开始定时：4.最后，在 main 函数中还要做对应的更改，替换 UIApplication 的调用：Swift版首先新建一个 UIApplication 的子类 CTApplication：由于 Swift 中没有 main 函数，所以需要自己手动建一个 main 函数，并设置入口：这时，Appdelegate 中的@UIApplicationMain会报错。下面是苹果官方对于@UIApplicationMain关键字的描述：Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class.If you do not use this attribute, supply a main.swift file with a main function that calls the UIApplicationMain(:::) function. For example, if your app uses a custom subclass of UIApplicationas its principal class, call the UIApplicationMain(:::) function instead of using this attribute.意思就是在类的最顶部声明 @UIApplicationMain，表示该类是Application 的 delegate，另外一种做法就是在 main.Swift 中调用 UIApplicationMain 函数，设置 delegate 和 application。而我们采取的是后面的办法，所以 delegate 冲突了，自然就会报错，只要把 Appdelegate 上的 @UIApplicationMain 关键字删除就可以了。剩下的操作与 OC 中的是一样的。具体的代码上传到 github 上了："}]