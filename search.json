[{"title":"从Heapsort与Mergesort看排序算法","date":"2019-12-03T02:28:26.000Z","url":"/fromHeapsortAndMergesortThinkSortAlgorithm.html","tags":["数据结构, 算法"],"content":"排序是最基本也是最广泛的一种算法，很多非常高效的算法都需要经过排序预处理。如果有了排好序的数据，那么许多问题的解决将会变得非常简单，例如： 搜索。采用二分搜索算法会使得搜索非常快速，其时间复杂度是 $O(logn)$ 最近点对。当数据是排好序时，最近点对必须按排序顺序彼此相邻，此时只要扫描列表就可以解决这个问题 选择。比如要确定数组中第 k 大的数据，如果数组是排好序的，只要确定第 k 个位置的数据。 算法设计之前不过，在设计一个排序算法之前，以下问题是我们需要考虑的： 数据是升序的还是降序的？ 对于复杂的数据记录，是否只针对某个 key 还是整个记录进行排序？ 当 key 相等时，应该怎么做？ 对于非数值数据怎么处理？ 数据的升序降序要依据具体的需求进行设计，其中涉及到排序算法中的 compare 操作。对于复杂数据记录，也需要根据实际需求进行设计，比如一个用户列表，有 username、email、phone numbers，是只根据其中一个字段进行排序，还是对所有字段进行排序呢？所有字段排序的话以哪个为主呢？在设计排序算法之前，是需要非常明确的。 对于相等 key 的处理会涉及到排序算法的稳定性。排序算法的稳定性是指，可以保证排序前两个相等的 key 在序列中的前后位置顺序，和排序后它们两个的前后位置顺序相同。稳定性的好处是：如果排序算法是稳定的，那么从一个 key 上排序，然后再从另一个 key 上排序，第一个 key 排序结果可以为第二个所用。这里需要说明的是，这种好处有且只有用在一个复杂的数据记录上，且第一个 key 排序顺序存在意义，需要在第二次排序的基础保持这种意义。比较常见的，比如我们首先通过价格由高到低筛选商品，再由销量从高到低筛选商品，这个时候排序的稳定性才是有意义的。如果只是简单的数字排序，或者复杂数据中的某一个数字排序，排序的稳定性将变得可有可无。算法的稳定性由具体的算法决定，不稳定的算法在某种条件下可以变成稳定的。对于不稳定的算法，只需举出一个实例，就可证明它的不稳定性。而对于稳定的算法，则必须要经过分析才能得到稳定的特性。 对于非数值的数据，比如单词字母的排序，则需要一个严格的定义，关于大小写，关于标点符号的。同时也要求我们需要设计一个良好的 compare 函数。 排序算法的分类常见的算法有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序。 冒泡排序、选择排序和插入排序都是非常直观的排序算法，直接将我们最直接的想法写成程序，这种程序也叫蛮力法。不需要过多的设计，把所有可能都列出来，然后一一比较。这种算法通常是有效的，但是不是高效的，其时间复杂度一般是 $O(n^2)$。一般写算法，我们可以先写出关于问题的蛮力算法，证明了问题是可解的，然后再分析需要优化的地方。 希尔排序则是插入排序的一种更高效的改进版本算法。是基于插入排序的以下两点特性而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率很高，几乎可以达到线性时间。 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动以为。 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性朝最终位置前进一大步，然后再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，不过此时数据几乎已经是排好序的了，所以插入效率非常高。希尔排序主要的一点就是如何设计步长，步长的初始值以及递减的程度。关于这点网上有许多严密的论述，读者可以自行搜索阅读了解，这里不再做过多赘述。 快速排序、归并排序和堆排序都是非常高效的算法，也是使用比较多的排序算法。快速排序和归并排序采用的都是分治法的策略，把序列分为更小的序列进行处理。堆排序则是从数据结构的角度入手，通过优化存储的数据结构来构成一个高效算法。 下面我们将分别介绍堆排序和归并排序，看如何从数据结构以及算法设计策略两种不同的角度来改进算法，使其高效。数据结构是算法的基础，良好的数据结构可以使我们的算法设计事半功倍。分治法则是一种非常重要的算法思想策略，其核心思想，将实例分减成相同性质的更小规模的实例，然后处理小实例，最终把结果合并起来。与递归思想十分的相像。 堆排序堆我们一般讨论的堆是指二叉堆（下面统一由堆指称），其性质是：父节点的键值总是保持固定的关系于任何一个字节点的键值，且每个节点的左子树和右子树都是一个堆。二叉堆是完全二叉树或是近似完全二叉树。 完全二叉树：二叉树是每个节点最多只有两个子节点的树结构。在一棵二叉树中，除最后一层外，若其他层都是满的，并且最后一层是满的，或者最后一层的叶子结点都靠左排列，则此二叉树为完全二叉树。为什么是靠左排列呢？因为如果树是按顺序存储的，那么可以通过下标计算其左子节点和右子节点的位置，如果根用 1 表示，那么一个节点的左子节点可以通过 $2i$ 计算，右子节点则可以通过 $2i+1$ 计算。如果是放在右节点的话，则会造成存储空间的浪费。 最大堆和最小堆当父节点的键值总是大于或等于任何一个子节点的键值时，为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时，为最小堆。 堆的存储堆一般用数组来表示，通过下标的计算来确定子节点或者父节点的位置。如果根节点在数组中的位置是 1，那么第 $n$ 个节点的左子节点的下标为 $2n$，右子节点的下标为 $2n+1$，其父节点的位置为 $n/2$。如果根是从 0 开始，那么左子节点和右子节点的位置分别是 $2n+1$ 和 $2n+2$，父节点的下标则是 $(n-1)/2$。 插入新节点在数组的最末尾插入新节点，然后自下而上调整子节点与父节点：比较当前节点与父节点，如果不满足堆性质则交换，从而使得当前子树满足堆的性质。 删除根节点对于最大堆，删除根节点就是删除最大值；对于最小堆，是删除最小值。然后把堆存储的最后那个节点移到根节点处。再从上而下调整父节点与它的子节点：比较当前节点与子节点，如果不满足堆性质，则交换二者，直至当前节点与它的子节点满足堆性质为止。 插入节点和删除根节点其实就是两个相反的操作。插入是在末尾插入，然后由下至上调整堆；删除根节点则是移除第一个节点，然后由上至下调整堆。 构造堆构造堆有两种方法：一种是从单节点的堆开始，依次插入新的节点。另一种是从节点任意放置的堆开始，自下而上对每一个子树执行堆的调整方法，使得当前子树成为一个满足堆性质的堆。 堆排序堆排序其实就是利用删除根节点的操作原理来实现的。堆排序的第一步是将数组堆化（最小堆还是最大堆依据需求而定，降序采用最大堆，升序采用最小堆），第二步是对堆化数据排序，每次都是将根节点也就是数组第一个元素与尾部节点调换位置，同时将遍历的数组长度减 1，重新调整被换到根节点的元素，使当前堆满足堆性质。直到没有未排序的堆长度为 0。 上面的一些概念性定义比较抽象，下面我们通过代码来实现一个堆、堆的相关操作以及堆排序。语言采用的是 Swift： 归并排序归并排序则是一个采用分治法的典型算法，分治法是把一个复杂的问题分成两个或更多个性质相同的子问题，直到最后的子问题可以简单的直接求解，原问题的解即子问题的解的合并。体现在归并排序上则是分为两个步骤： 分割：递归地把当前序列平均分割成两半 合并：在保持元素顺序的同时将上一步得到的子序列合并到一起，即将两个已经排好序的序列合并成一个序列的操作 在实际实现上，我们也需要分成这两步进行求解。第一步递归地将数组平均分割，直到不能分割，即只有一个元素的序列。第二步则是如何将两个序列合并到一起，通过比较第一个和第二个序列中元素的大小，插入到结果序列中，如果其中一个序列中的元素已经取完了，则直接将另外一个序列中的所有元素拼接到结果序列中。代码实现如下： 归并排序的重点在于对递归对理解，因为其思想跟递归的一样。归并排序高效的原因在于，其各层分治递归可以同时进行，即其每次处理的规模较大，同蛮力法每次只能处理一个规模的数据相比，速度自然要快得很多。 结语：对于同一个问题的处理，有着许多非常不同的高效的算法。我们可以通过构建更合理的数据结构，使得问题的处理变得更高效；也可以通过对问题的建模与分解，将复杂问题变成简单问题求解。堆排序和归并排序给我们分别提供了这两种处理问题的方式。对于同一问题的不同处理，也要求了我们对于数据结构与问题建模的有一定的理解，才能更灵活多变的解决问题，不拘泥于一种解决方案。对于问题的求解，如果没有类似的经验或者找不到处理的入口，则可以通过蛮力法先求解问题，再优化算法中处理较慢的那一部分。"},{"title":"如何用V2Ray科学上网","date":"2019-11-29T06:06:21.000Z","url":"/how-to-freedom.html","tags":["科学上网"],"content":"什么是 V2Ray想要通过 V2Ray 科学上网，先得了解 V2Ray 是什么。根据 V2Ray 指南比较官方的描述： V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。 官方中介绍Project V 提供了单一的内核和多种界面操作方式。内核（V2Ray）用于实际的网络交互、路由等针对网络数据的处理，而外围的用户界面程序提供了方便直接的操作流程。 简单点说，V2Ray 就是一个跟 Shadowsocks 差不多的代理软件，可以让我们科学上网。只不过相对来说，V2Ray 功能更强大一点，同时配置也更复杂一点。而且鉴于现在走 SS 协议的代理基本都会受到干扰，科学上网起来也没那么流畅，这时候就需要了解及配置一套自己的 V2Ray了。V2Ray 更加稳定，而且传输速度相对 SS 也更快一点。 搭建 V2Ray 需要什么首先，简单的 V2Ray 只需要一台墙外的 VPS 就可以了，同时也需要一点 Linux 系统的知识。VPS 的话香港、日本、新加坡、美国的都行。只不过是延迟的差异而已，地理位置越靠近国内的延迟越低。在搬瓦工、Vlutr、DigitOcean 都可以买到对应的 VPS，其中搬瓦工是最出名的，也是最多人购买的，比较推荐。只不过如果你的 IP 不幸被封，需要 8 美刀更换一个 IP，而且搬瓦工一般都是按年付费的。Vlutr 则是我之前用的比较多的一家平台，可以免费更换 IP，被封了随时可以新建实例，而且是按时按月收费的，如果大环境不太爽畅，可以用 Vlutr 过度一下。它的缺点就是比较不稳定，配置相对也没有那么好。DigitOcean 我没有用过，所以就不做评价了。 但是，如果你很幸运的拥有一个 Google 账号，则可以通过 GoogleCloud 新用户的规则白嫖一年 VPS（我现在就白嫖着～）。GoogleCloud 会赠送新用户 300 美刀，可以使用其下面的云产品，300 美刀在一年之内需用完，过期作废。但国内用户开通 GoogleCloud 会比较麻烦，首先你得已经番羽墙了，然后要拥有一个境外的双币卡，才能完成新用户的认证。不过，有一个解决办法就是通过 P 卡去开通（P 卡：Payoneer，一个虚拟信用卡网站），在知乎上有一篇文章，新用户申请谷歌云300美金失败，怎么办？，我就是通过这个方法申请开通成功的。然后就是注册实例之类的，就不再赘述了，网上都有许多相关的文章，随便找篇看看就知道怎么回事了。 当然，上面只是最简单的需要的东西。如果想更安全更稳定更快速的科学上网，就还需要一个域名，域名的作用是解析 VPS 主机，并通过它进行再次代理转发的。域名是个很便宜的东西，随便申请一个就好了，越便宜越好的那种。 个人建议：VPS 最好选择 Ubuntu 或者 Debain 系统的 前期准备到了这一步，就默认上面所说的东西你都已经准备好了。现在开始前期的准备工作： 将申请下来的 VPS 解析到申请好的域名 为域名申请 SSL 证书 安装 Nginx 将 VPS 解析到申请好的域名就不做过多描述了，通过 DNSPod 或者申请域名的平台应该都可以进行解析。首先，登入到申请好的 VPS 上： 为域名申请 SSL 证书我们可以通过 cerbot 给域名生成对应的 SSL 证书： 1. 下载并给 cerbot 赋予可执行权限首先，选择保存 cerbot 的目录，我们可以选择 /usr/local/src，cd 到想保存的目录。然后用 wget 命令下载 cerbot： 然后再给 cerbot 赋予可执行权限： 2. 利用 cerbot 申请 Let’s Encry 证书申请 Let’s Encry 证书需要以下几个条件： 系统的 root 权限 443 端口未被占用，防火墙放行 443 端口，且外网能够直接访问本机的 443 端口 域名解析到了当前主机 如果申请失败了，确认一下以上几点是否都满足。现在可以申请 SSL 证书了： 第一次安装需要输入一些必要的信息，主要如下： 申请成功之后，会有一个证书保存的路径显示，可以记录下来，后面需要用到。如果忘记了也没关系，证书一般都保存在 /etc/letsencrypt/live/xxx下面，在这里你可以找到申请好的证书，有你的域名的那两个文件就是对应的证书。 在证书快到期时，也可以通过下面的命令更新证书信息： 安装 NginxCentOS 系统添加 Nginx 官方源CentOS 系统官方源仓库文件在 /etc/yum.repos.d，只需要在下面新建一个文件保存 Nginx 的源就可以了，例如新建一个叫 nginx.repo 的文件，然后复制以下内容进去： 保存文件后，就可以直接安装 Nginx 了： Ubuntu 及 Debain 系统添加官方源用编辑器打开 /etc/apt/sources.list，Debain 添加以下内容： Ubuntu 添加以下内容： 用命令 cat/etc/os-release 查询到实际发行版本号，替换上面内容中的 codename。 添加完上面内容后，还需要添加 Nginx 官方的 Key，不然会提示 Key 错误： 最后先更新仓库源信息再安装 Nginx： 到了这里，前期的准备工作基本完成了，下面则需要进入配置环节了。 安装 V2Ray用官方提供的命令一键安装 V2Ray： 配置 V2RayV2Ray 的配置文件放在 /etc/V2Ray/config.json，修改之前先备份一下： 在原先的默认配置中，修改或者添加下面的配置： 修改配置之后，可以用 V2Ray 自带的测试工具检测一下配置是否正确： 配置 Nginx 转发 websocket在 /etc/nginx/conf.d 新建一个虚拟主机配置文件，内容如下： 保存之后用 Nginx 自带的配置文件检测功能检查下是否有问题：nginx -t 没问题的话重启一下 V2Ray 和 Nginx 就可以了： 客户端的配置其实 V2Ray 并没有所谓的客户端，它只是个配置而已，客户端的功能主要是保持和服务器的配置一样。Windows 上推荐的客户端是 V2RayW，Mac 上推荐的是 V2RayX，iOS 客户端推荐 Kitsunebi（需要在美区下载），Android 客户端推荐 V2RayNG。这里主要介绍一下 Mac 上 V2RayX 的配置，其他配置基本雷同。 V2RayX 的配置界面长这样： 下面对各个功能及配置进行详细说明： 到这里基本配置就完成了，接下来配置 websocket 和 TLS，点击配置中的 transport settings...，进入到： 到这里，客户端的配置也就已经完成了，可以愉快的科学上网了：) 如果，你并不想做那么复杂的配置，只想简单的科学上网，则只需要使用 V2Ray 默认生成的配置文件，将客户端的 id 及传输类型，配置成跟服务器中的一样就可以了。初次配置 V2Ray 会有点懵圈，因为它并不像 SS 一样，有严格的客户端功能配置，它只是一系列的配置文件而已，inbound 和 outbound 只是出站跟入站的配置，客户端也就是我们上网是 inbound，服务器则是 outbound。理清这些概念，就可以解决 V2Ray 中大部分的问题。"},{"title":"git使用SSH配置一直需要输入密码的坑","date":"2019-11-28T02:07:07.000Z","url":"/git%E4%BD%BF%E7%94%A8SSH%E9%85%8D%E7%BD%AE%E4%B8%80%E7%9B%B4%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%9A%84%E5%9D%91.html","tags":["git ssh"],"content":"一般 git 提供了 HTTPS 和 SSH（Secure Shell） 两种认证方式。HTTPS 比较简单，只需要输入对应的 user 和 password 就可以了。SSH 则相对复杂一点，需要使用 ssh 命令生成 RSA 密钥对，将 public key 提交到服务器，本地保留 private key。SSH 还可以允许我们通过 config 来管理多用户，例如：一般我们会有一个自己的 github 账户，通过 SSH 管理；同时，公司可能会有一个另外的源码管理平台，如 gitlab 或 gitee 等，一些公司还会在 gitlab 上搭建自有服务器。SSH 如何生成密钥对，如何通过 config 管理，这里就不做过多赘述了，网上随便一搜或者 github 中都有详细的说明：） SSH 的 config 格式一般如下： 在前不久，上班摸鱼逛 v2ex 的时候，看见一个人发了一个帖子： 在上家公司的时候，我也遇到了同样的问题。每次重启 iTerm2 或者电脑，再 pull 或者 push 代码，就提示要输入密码，无论输入什么密码都提示错误。我一度以为是我人品问题，后来一阵摸索瞎试之后，将 Host 改成 HostName 相同的，就可以解决了。也就是说，如果你公司源码管理平台的地址是 gitlab.xxx.xxx，只需要将 Host 和 HostName 一起改成这个，就可以了。 再回过头来看看，config 中的 Host 和 HostName，Host 是指主机别名，HostName 是指向真实地址。也就是说如果服务器的别名是 test，真实 IP 地址是 0.0.0.0，只需要将 Host 配置成 test，HostName 指向 0.0.0.0，然后再配合本地私钥就可以登陆上去访问了。但在实际中，公司搭建自有主机的时候，其实际主机别名跟其实际地址指向是一样的。如果是搭建在 gitlab 中，如果只在 config 中将 Host 指向 gitlab，那么就会出现一直需要密码的情况，只能重新生成密钥对去进行一次性的访问。 希望这篇文章能解决你在 SSH 使用过程中出现的类似的问题：），Have a good day！"},{"title":"Mac快捷键","date":"2019-11-08T06:26:02.000Z","url":"/Mac%E5%BF%AB%E6%8D%B7%E9%94%AE.html","tags":["杂谈低语"],"content":"Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的官方文档里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。 这些快捷键在 Mac 里面是通用的，也就意味着在几乎所有的有文本输入的地方，都可以用得上，一次学习，使用Anywhere :)。要熟悉掌握这些组合，还是要下一定功夫勤加练习的，不然右手又会不自觉地去触摸鼠标了。不过还是有一定技巧的，主要是掌握 ctl、shift、fn 的组合而已。 （强烈建议大家将键盘上的大小写切换键改为 ctl 键，因为 ctl 的作用远比大小写切换重要多了，大小写切换完全可以使用 shift + 字母的方式进行输入，但大小写键在键盘上却占据了很重要的位置，ctl缩在角落瑟瑟发抖）。修改方法：系统设置 -&gt; 键盘 -&gt; 修饰键（在右下角）-&gt; 大写锁定键改为 Control 光标移动cmd + ← 移动至行首 cmd + → 移动至行尾 fn + ↓ 向下翻页 fn + ↑ 向上翻页 option + ← 向前跳一个词 option + → 向后跳一个词 ctl + p 光标向上移动一行 ctl + n 光标向下移动一行 ctl + b 光标向前移动一个字母 ctl + f 光标向后移动一个字母 ctl + e 光标移动到行尾 ctl + a 光标移动到行首 选取option + shift + ← 向前选中一个单词 option + shift + → 向后选中一个单词 cmd + shift + → 从当前光标选中到行尾 cmd + shift + ← 从当前光标选中到行首 删除fn + delete 向后删除 option + delete 向前删除一个单词 fn + option + delete 向后删除一个单词 cmd + delete 从当前光标删除到行首 fn + cmd + delete 从当前光标删除到行尾 Snap最后，也推荐给大家一个软件 Snap，在 AppStore 可以直接下载。这个软件的作用是绑定应用快捷键的，可以把对应的应用绑定成自己喜欢的快捷键，通过快捷键快速启动和切换应用，时间复杂度是 O(1)，远比用 cmd + tab（时间复杂度 O(n)）或者用鼠标点击（时间复杂度 O(n^2)）快多了 软件主界面长这样： 这个主要是设置默认快捷键的，比如这里设置了 ctl + cmd，那么你就可以通过 ctl + cmd + 1 的快捷键来启动或者切换 Dock 上的第一个应用，ctl + cmd + 2 启动或者切换第二个，以此类推。 上面这种方法不是很建议，因为需要记住应用在 Dock 上的位置或者自己手动排列 Dock 位置。还有另外一种方法就是 Manual，就是上面说的应用绑定快捷键，界面长这样： 点击左下角就可以选择一个应用，然后输入对应的快捷键，后面就可以愉快的玩耍了 ^-^"},{"title":"What's New in Xcode11","date":"2019-11-05T07:38:21.000Z","url":"/What-s-New-in-Xcode11.html","tags":["iOS"],"content":"WWDC19 - What’s New in Xcode11WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 WWDC 2019 Session 401，顺便做一下记录。 首先，对 Xcode11 的整体改进做一个预览： 整体的改变还是挺多的，下面一一对改进的功能进行说明。 右上角功能键的改进首先，Xcode 11 改变的是右上角的按钮，Xcode 10 上是三个按钮，到了 11 已经变成了两个按钮： 原先的 Source Control Log 被移到了右侧栏里面： 原先的比较常用的切换 Assitant Editor 和 Authors 一起并入到了 Editor Options 里面，并将 Editor Options 移到了每个独立的编辑窗口里面： 上面 Xcode 11 的 Assistant 就是原先 Xcode 10 右上角的那两个圈圈 Editor Options 中同时新增了一个 Swift UI 的预览，当项目中使用到了 Swfit UI 的时候，可以预览 Swift UI 的效果 现在 Xcode 11 上面的两个按钮的功能变成了 Library 和 Code Review： Library 的主要功能是：选择 IB 控件、文档、代码块、图片资源以及颜色 Code Review 的主要功能是：比较同一源文件源码的改动 Editor Splitting在 Xcode 11 里面，增加了一个 Editor Spliting 的功能，可以随时随地的增加一个 Editor： Editor Spliting 默认的是往右边增加，按住 option 键再点击这个按钮，就可以在下面增加新的 Editor 可以通过按住 shift + option 并点击源文件，来管理 Editor，点击的源文件那个窗口会变成选中效果，可以用鼠标或者键盘方向键进行移动，移动完成后，点击键盘上的 return，原先选中的源文件就会插入或者移动到当前位置 MinimapXcode 11 比较大的一个改动就是新增了 Minimap： Minimap 主要是提供导航作用的，点击 Minimap 的任意位置，源码便会滚动到点击的地方。 当鼠标悬停在上面时，会显示当前的方法名： 同时按住 cmd 键的话，会显示当前所有的方法名： 当源码中有 warning 或者断点时，在 Minimap 中也会显示 源码中的 marks 在 Minimap 里可以直接看到： 当在源码中搜索关键字时，所有符合条件的在 Minimap 中会有选中效果： 源码 EditorXcode 11 中通过 cmd + 右键点击方法名，可以给方法添加参数注释。新增了参数时，通过这个方法会自动拼接新的参数： cmd + 右键点击参数，选择 Edit All in Scope，可以同时修改方法名、方法内、注释里面的参数名称： 当对源码进行了修改时，在 Editor 的左侧会出现一个蓝色条，点击这个蓝色条，可以选择 Show Change 和 Discard Change。Discard Change 的作用是撤销修改，Show Change 的作用是显示哪些地方进行了改动： 除此之外，Xcode 11 还有着更好的自动补全、增加了新的 Theme，优化了一些细节体验"},{"title":"Cordova in iOS","date":"2016-09-07T16:00:00.000Z","url":"/Cordova.html","tags":["Cordova"],"categories":["Cordova"],"content":"Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。 环境搭建安装Cordova: 第一个参数为工程文件夹第二个参数为应用的的 id 名，和 Xcode 中的 bundle Id 类似第三个参数为工程名字 添加 iOS 平台支持 进入刚刚创建的工程目录下，执行： 执行这个命令只出现光标没有反应的话，是因为网络原因。由于国内的网络环境，虽然的 npm 官方站点  并没有被墙，但是下载第三方依赖包的速度有时还是不理想，我们可以改用淘宝的 NPM 镜像。 打开 ~/.npmrc 文件： 添加以下内容： 保存退出，再执行命令就会发现很快就配置好了。 打开 platforms/ios 目录，就可以运行我们的创建的工程了。"},{"title":"OpenGL实战(一) - 简单图形绘制","date":"2016-08-30T16:00:00.000Z","url":"/OpenGLES-2.html","tags":["OpenGL ES"],"categories":["OpenGL ES"],"content":"在上一篇文章中我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码+知识点+API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我（评论采用disqus，如果加载不出来，翻个墙试一下，联系方式见关于我）。 渲染屏幕====首先，将控制器继承自GLKViewController，并初始化一个GLKView，设置为它的View： 只需在GLKView的代理方法(void)glkView:(GLKView *)view drawInRect:(CGRect)rect中，调用glClear的系列函数就可以用OpenGL ES对屏幕进行渲染了： 现在来做一个酷炫的效果，让屏幕显示闪烁。当设置GLKViewController代理的时候，每一帧动画GLKViewController都会告诉我们，它会在1秒内多次调用draw方法，GLKViewController的代理中，我们可以在GLKViewController的代理方法(void)glkViewControllerUpdate:(GLKViewController *)controller方法来更新屏幕的颜色。 首先定义两个参数并初始化: 设定GLKViewController的刷新频率: 更新(void)glkView:(GLKView *)view drawInRect:(CGRect)rect中的代码，在GLKViewController的代理方法中更新屏幕颜色: 这样就实现了屏幕黑红闪烁效果，Demo可以在这里找到。 绘制图形现在我们来利用OpenGL ES绘制一个正方形。因为OpenGL ES只能渲染三角形，所以要用两个三角形来组成一个正方形。首先创建一组顶点数据和索引数据： 顶点数据中包括了顶点位置和对应的颜色，索引数据则是顶点数组的索引。然后我们需要向OpenGL ES发送数据和缓存数据： 关于 usage 的一些说明： GL_STREAM_DRAW: 数据只指定一次，并且最多只有几次作为绘图和指定图像函数的源数据 GL_STREAM_READ: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次由应用程序作为数据值使用 GL_STREAM_COPY: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次作为绘图和指定图像函数的源数据 GL_STATIC_DRAW: 数据只指定一次，但是可以多次几次作为绘图和指定图像函数的源数据 GL_STATIC_READ: 数据从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用 GL_STATIC_COPY: 数据从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据 GL_DYNAMIC_DRAW: 数据可以多次指定，并且可以多次几次作为绘图和指定图像函数的源数据 GL_DYNAMIC_READ: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用 GL_DYNAMIC_COPY: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据 在OpenGL ES2.0当中，无论渲染什么图形，都必须用到着色器。着色器是用类C语言-GLSL语言写的，如果想要自定义一个着色器，那么学习这门语言十分有必要。现在GLKBaseEffect这个类为我们提供了一些通用的着色器，在还没有掌握GLSL的情况下，我们目前可以使用它来帮我们实现效果： 最后在代理方法中启动着色器: 这样我们就可以看到最终的效果了： 细心观察就会发现，我们想要的结果是一个正方形，现在出来的效果却是一个矩形，这是为什么呢？因为默认的，“Effect”的投影矩阵是一个单位矩阵，它不做任何变换，将场景（-1，-1，-1）到（1，1，1）的立文体范围的物体，投射到屏幕的X：-1，1，Y：-1，1。因此，当屏幕本身是非正方形时，正方形的物体将被拉伸，从而显示为矩形。所以我们要在update 中修改投影矩阵： 最终通过这段代码就能得到我们想要的结果了：一个正方形（Demo 在这里）。在学习过程中，踩了很多坑，包括一开始的图像显示不出来，API 的意思也不明确。后来通过 Google 查阅相关资料，把一些 bug 解决了，同时也加深了对 OpenGL ES 的理解，学习到了很多的东西。上面的知识，在代码中我已经注释的很清楚了，如果有不懂的地方或者不正确的地方，欢迎指正交流~"},{"title":"初识 OpenGL ES","date":"2016-08-28T16:00:00.000Z","url":"/OpenGLES-1.html","tags":["OpenGL ES"],"categories":["OpenGL ES"],"content":"在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！ 什么是OpenGL ES OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。 OpenGL ES是从OpenGL裁剪定制而来的，去除了glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性。经过多年发展，现在主要有两个版本，OpenGL ES 1.x针对固定管线硬件的，OpenGL ES 2.x针对可编程管线硬件。OpenGL ES 1.0是以OpenGL 1.3规范为基础的，OpenGL ES 1.1是以OpenGL 1.5规范为基础的，它们分别又支持common和common lite两种profile。lite profile只支持定点实数，而common profile既支持定点数又支持浮点数。OpenGL ES 2.0则是参照OpenGL 2.0规范定义的，common profile发布于2005-8，引入了对可编程管线的支持。OpenGL ES 3.0于2012年公布，加入了大量新特性。 - - - - 维基百科 苹果官方文档中对于OpenGL ES的描述为：OpenGL ES让App拥有了利用底层图形处理器的能力，iOS设备上的GPU可以执行复杂的2D和3D绘图，以及在最终图像上的每个像素的复杂着色计算。OpenGL ES是低级的、以硬件为中心的基于C的API，可以与iOS应用无缝集成。OpenGL ES规范没有定义窗口层，取而代之，当有任何绘图命令写入，主机操作系统必须定义一个方法来创建OpenGL ES渲染上下文，用来接受命令和帧缓冲。 OpenGL ES基本概念坐标系 由于OpenGL ES可以用来绘制2D和3D图形，所以它的坐标是一个三维坐标，如果应用只涉及到2D，那么可以不考虑Z轴。 纹理坐标 一般OpenGL ES中的纹理坐标都是二维的，原点在左下角，与计算机中的图像坐标并不一致，二者的差别在于围绕横轴翻转180°。 顶点数据&amp;&amp;索引 顶点数据是一个数组，里面存的是顶点坐标。而索引则是顶点数组的对应的索引和串联关系。 上面顶点数组里面的一行就代表了坐标系里面的x,y,z三个坐标系，代表了一个顶点的位置，里面总共包含了4个点。索引数组则是顶点数据的索引，每一行代表一个连接关系，从0-1-2，从1-3-0。 EAGLContext在使用OpenGL ES之前，必须初始化一个EAGLContext对象，并且将它设置为当前上下文 注意事项： 每个线程都会维护一个当前上下文。 设置了一个新的上下文，EAGL会释放当前上下文，并且获取新的上下文。 当在同一个线程中转换两个或者更多的上下文时，在设置一个新的上下文作为当前上下文之前，需要调用glFlush函数，确保之前的一些命令可以及时传递给图像硬件设备。 调用glFlush函数时需导入OpenGLES/ES2/gl.h框架。 GLKViewGLKView介绍 GLKView管理着OpenGL ES的基础，来提供绘制代码的地方。GLKView提供了基于OpenGL ES并等效于标准UIView的绘图生命周期。一个UIView实例自动配置图像上下文，所以drawRect:只需执行Quartz 2D绘图命令，GLKView实例自动配置本身，所以你的绘图方法只需执行OpenGL ES命令。GLKView通过维护一个保存着OpenGL ES绘图命令的帧缓冲对象来实现这一功能，一旦你的绘图方法完成，就会自动把结果呈现给Core Animation。 GLKView初始化方法 GLKViewDelegate GLKView能够为OpenGL ES的绘制提供一个简单的界面，因为它管理着OpenGL ES渲染过程的部分标准： 在调用绘图方法之前，视图： 使EAGLContext为当前上下文 基于当前大小、比例因子和drawable属性（如果需要），创建帧缓冲对象和渲染缓冲区 将帧缓冲对象作为绘图命令的当前目标 设置OpenGL ES视图端口来匹配帧缓冲区大小 绘图方法执行完后，视图： 解析多重采样缓冲区（如果允许多重采样） 丢弃不需要的渲染缓冲区 将渲染缓冲区内容交给Core Animation缓存和显示 参考： OpenGL ES Programming Guide for iOS "},{"title":"iOS 事件拦截","date":"2016-07-19T16:00:00.000Z","url":"/iOSEvent.html","tags":["事件拦截"],"categories":["事件机制"],"content":"在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。 iOS事件机制iOS 中的事件分为三类：触摸事件（单点、多点、手势），传感器事件（加速传感器）和远程控制事件（官方文档），我们遇到情况是第一种也就是触摸事件的机制。 响应者链当一个事件发生时，如果 first responder 不做处理，那么就会往下传递，如果下一个 responder 也不处理，那么就会继续传递到再下一个 responder 中，直到有一个 responder 处理或者没有 responder 了，如果没有 responder 处理这个事件，那么这个事件就被抛弃了。这些 responder 按照传递顺序连接起来就构成了响应者链。 iOS 中的响应者链： 从图中我们可以观察到，响应者链有以下几个特点： 响应者链通常由 initial view 开始。 View 的 nextResponder 是它的 superView，如果 View 已经是它所在的 ViewController 中的 top view，那么 next responder 就是它所在的 ViewConTroller。 ViewController 如果有 superViewController，那么它的 nextResponder 就是它superViewController 最上面的 View。如果没有，那么它的 nextResponder 就是 Window。 Window 的 nextResponder 指向 Application，Application 是整个响应者链的顶层，它的 nextResponder 指向 nil。也就是说当事件传递到 Application 不被处理的话就会被抛弃了。 由于 UI 的复杂性，整个响应者链是需要通过计算的，而计算顺序基本是与响应者链分发相反的。无论哪种事件，都是系统本身先获得，再交给 UIApplication，由 UIApplication 决定交给谁去处理。 关于事件分发的计算网上有很多文章，我就不赘述了。通过上述了解，我们可以得出一个结论：如果我们需要拦截一个事件，最好的机会是在 UIApplication 里面。 需求具体实现OC 版根据上面的结论，我们目前的思路是继承 UIApplication，然后实现某一方法，进行事件拦截。根据查阅资料，重写 UIApplication 的 sendEvent方法可以达到目的，sendEvent介绍如下： sendEvent: Dispatches an event to the appropriate responder objects in the application. ParameterseventA UIEvent object encapsulating the information about an event, including the touches involved. DiscussionSubclasses may override this method to intercept incoming events for inspection and special dispatching. iOS calls this method for public events only. 具体代码实现： 新建一个继承 UIApplication 的 CTApplication，重写 sendEvent 方法，并判断是否为触摸事件： 2.由于需要检测用户多长时间没有点击屏幕，需要加一个定时器来进行倒计时，设置定时器的方法写在 CTApplication 的 init 方法中： 3.再回到 sendEvent 方法中，如果该方法被触发了，那么让定时器失效，重新开始定时： 4.最后，在 main 函数中还要做对应的更改，替换 UIApplication 的调用： Swift版首先新建一个 UIApplication 的子类 CTApplication： 由于 Swift 中没有 main 函数，所以需要自己手动建一个 main 函数，并设置入口： 这时，Appdelegate 中的@UIApplicationMain会报错。下面是苹果官方对于@UIApplicationMain关键字的描述： Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class. If you do not use this attribute, supply a main.swift file with a main function that calls the UIApplicationMain(:::) function. For example, if your app uses a custom subclass of UIApplicationas its principal class, call the UIApplicationMain(:::) function instead of using this attribute. 意思就是在类的最顶部声明 @UIApplicationMain，表示该类是Application 的 delegate，另外一种做法就是在 main.Swift 中调用 UIApplicationMain 函数，设置 delegate 和 application。而我们采取的是后面的办法，所以 delegate 冲突了，自然就会报错，只要把 Appdelegate 上的 @UIApplicationMain 关键字删除就可以了。剩下的操作与 OC 中的是一样的。 具体的代码上传到 github 上了："}]