<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.58.3" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>悉达多｜PainMaker | 知也者，所以知也，而不必知</title>
    <meta property="og:title" content="悉达多｜PainMaker | 知也者，所以知也，而不必知">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="">
    <meta name="description" content="">
    <meta property="og:url" content="http://superchun.cn/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="http://superchun.cn/index.xml" title="悉达多｜PainMaker" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="http://superchun.cn">
                            悉达多｜PainMaker
                        </a>
                    </h1>
                
                <p class="description">知也者，所以知也，而不必知</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://superchun.cn">首页</a>
                    
                    <a  href="http://superchun.cn/archives/" title="归档">归档</a>
                    
                    <a  href="http://superchun.cn/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/%E4%BB%8Eheapsort%E4%B8%8Emergesort%E7%9C%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="从Heapsort与Mergesort看排序算法" >从Heapsort与Mergesort看排序算法</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年12月3日
                            </date>
                            
                            <div class="post-content">
                                排序是最基本也是最广泛的一种算法，很多非常高效的算法都需要经过排序预处理。如果有了排好序的数据，那么许多问题的解决将会变得非常简单，例如：
 搜索。采用二分搜索算法会使得搜索非常快速，其时间复杂度是 $O(logn)$ 最近点对。当数据是排好序时，最近点对必须按排序顺序彼此相邻，此时只要扫描列表就可以解决这个问题 选择。比如要确定数组中第 k 大的数据，如果数组是排好序的，只要确定第 k 个位置的数据。  算法设计之前 不过，在设计一个排序算法之前，以下问题是我们需要考虑的：
 数据是升序的还是降序的？ 对于复杂的数据记录，是否只针对某个 key 还是整个记录进行排序？ 当 key 相等时，应该怎么做？ 对于非数值数据怎么处理？  数据的升序降序要依据具体的需求进行设计，其中涉及到排序算法中的 compare 操作。对于复杂数据记录，也需要根据实际需求进行设计，比如一个用户列表，有 username、email、phone numbers，是只根据其中一个字段进行排序，还是对所有字段进行排序呢？所有字段排序的话以哪个为主呢？在设计排序算法之前，是需要非常明确的。
对于相等 key 的处理会涉及到排序算法的稳定性。排序算法的稳定性是指，可以保证排序前两个相等的 key 在序列中的前后位置顺序，和排序后它们两个的前后位置顺序相同。稳定性的好处是：如果排序算法是稳定的，那么从一个 key 上排序，然后再从另一个 key 上排序，第一个 key 排序结果可以为第二个所用。这里需要说明的是，这种好处有且只有用在一个复杂的数据记录上，且第一个 key 排序顺序存在意义，需要在第二次排序的基础保持这种意义。比较常见的，比如我们首先通过价格由高到低筛选商品，再由销量从高到低筛选商品，这个时候排序的稳定性才是有意义的。如果只是简单的数字排序，或者复杂数据中的某一个数字排序，排序的稳定性将变得可有可无。算法的稳定性由具体的算法决定，不稳定的算法在某种条件下可以变成稳定的。对于不稳定的算法，只需举出一个实例，就可证明它的不稳定性。而对于稳定的算法，则必须要经过分析才能得到稳定的特性。
对于非数值的数据，比如单词字母的排序，则需要一个严格的定义，关于大小写，关于标点符号的。同时也要求我们需要设计一个良好的 compare 函数。
排序算法的分类 常见的算法有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序。
冒泡排序、选择排序和插入排序都是非常直观的排序算法，直接将我们最直接的想法写成程序，这种程序也叫蛮力法。不需要过多的设计，把所有可能都列出来，然后一一比较。这种算法通常是有效的，但是不是高效的，其时间复杂度一般是 $O(n^2)$。一般写算法，我们可以先写出关于问题的蛮力算法，证明了问题是可解的，然后再分析需要优化的地方。
希尔排序则是插入排序的一种更高效的改进版本算法。是基于插入排序的以下两点特性而提出改进方法的：
 插入排序在对几乎已经排好序的数据操作时，效率很高，几乎可以达到线性时间。 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动以为。  希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性朝最终位置前进一大步，然后再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，不过此时数据几乎已经是排好序的了，所以插入效率非常高。希尔排序主要的一点就是如何设计步长，步长的初始值以及递减的程度。关于这点网上有许多严密的论述，读者可以自行搜索阅读了解，这里不再做过多赘述。
快速排序、归并排序和堆排序都是非常高效的算法，也是使用比较多的排序算法。快速排序和归并排序采用的都是分治法的策略，把序列分为更小的序列进行处理。堆排序则是从数据结构的角度入手，通过优化存储的数据结构来构成一个高效算法。
下面我们将分别介绍堆排序和归并排序，看如何从数据结构以及算法设计策略两种不同的角度来改进算法，使其高效。数据结构是算法的基础，良好的数据结构可以使我们的算法设计事半功倍。分治法则是一种非常重要的算法思想策略，其核心思想，将实例分减成相同性质的更小规模的实例，然后处理小实例，最终把结果合并起来。与递归思想十分的相像。
堆排序 堆 我们一般讨论的堆是指二叉堆（下面统一由堆指称），其性质是：父节点的键值总是保持固定的关系于任何一个字节点的键值，且每个节点的左子树和右子树都是一个堆。二叉堆是完全二叉树或是近似完全二叉树。
 完全二叉树：二叉树是每个节点最多只有两个子节点的树结构。在一棵二叉树中，除最后一层外，若其他层都是满的，并且最后一层是满的，或者最后一层的叶子结点都靠左排列，则此二叉树为完全二叉树。为什么是靠左排列呢？因为如果树是按顺序存储的，那么可以通过下标计算其左子节点和右子节点的位置，如果根用 1 表示，那么一个节点的左子节点可以通过 $2i$ 计算，右子节点则可以通过 $2i+1$ 计算。如果是放在右节点的话，则会造成存储空间的浪费。
 最大堆和最小堆 当父节点的键值总是大于或等于任何一个子节点的键值时，为最大堆。……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/%E4%BB%8Eheapsort%E4%B8%8Emergesort%E7%9C%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/%E5%A6%82%E4%BD%95%E7%94%A8v2ray%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" title="如何用V2Ray科学上网" >如何用V2Ray科学上网</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月29日
                            </date>
                            
                            <div class="post-content">
                                什么是 V2Ray 想要通过 V2Ray 科学上网，先得了解 V2Ray 是什么。根据 V2Ray 指南比较官方的描述：
 V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。 官方中介绍Project V 提供了单一的内核和多种界面操作方式。内核（V2Ray）用于实际的网络交互、路由等针对网络数据的处理，而外围的用户界面程序提供了方便直接的操作流程。
 简单点说，V2Ray 就是一个跟 Shadowsocks 差不多的代理软件，可以让我们科学上网。只不过相对来说，V2Ray 功能更强大一点，同时配置也更复杂一点。而且鉴于现在走 SS 协议的代理基本都会受到干扰，科学上网起来也没那么流畅，这时候就需要了解及配置一套自己的 V2Ray了。V2Ray 更加稳定，而且传输速度相对 SS 也更快一点。
搭建 V2Ray 需要什么 首先，简单的 V2Ray 只需要一台墙外的 VPS 就可以了，同时也需要一点 Linux 系统的知识。VPS 的话香港、日本、新加坡、美国的都行。只不过是延迟的差异而已，地理位置越靠近国内的延迟越低。在搬瓦工、Vlutr、DigitOcean 都可以买到对应的 VPS，其中搬瓦工是最出名的，也是最多人购买的，比较推荐。只不过如果你的 IP 不幸被封，需要 8 美刀更换一个 IP，而且搬瓦工一般都是按年付费的。Vlutr 则是我之前用的比较多的一家平台，可以免费更换 IP，被封了随时可以新建实例，而且是按时按月收费的，如果大环境不太爽畅，可以用 Vlutr 过度一下。它的缺点就是比较不稳定，配置相对也没有那么好。DigitOcean 我没有用过，所以就不做评价了。
但是，如果你很幸运的拥有一个 Google 账号，则可以通过 GoogleCloud 新用户的规则白嫖一年 VPS（我现在就白嫖着～）。GoogleCloud 会赠送新用户 300 美刀，可以使用其下面的云产品，300 美刀在一年之内需用完，过期作废。但国内用户开通 GoogleCloud 会比较麻烦，首先你得已经番羽墙了，然后要拥有一个境外的双币卡，才能完成新用户的认证。不过，有一个解决办法就是通过 P 卡去开通（P 卡：Payoneer，一个虚拟信用卡网站），在知乎上有一篇文章，新用户申请谷歌云300美金失败，怎么办？，我就是通过这个方法申请开通成功的。然后就是注册实例之类的，就不再赘述了，网上都有许多相关的文章，随便找篇看看就知道怎么回事了。……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/%E5%A6%82%E4%BD%95%E7%94%A8v2ray%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/git%E4%BD%BF%E7%94%A8ssh%E9%85%8D%E7%BD%AE%E4%B8%80%E7%9B%B4%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%9A%84%E5%9D%91/" title="git使用SSH配置一直需要输入密码的坑" >git使用SSH配置一直需要输入密码的坑</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月28日
                            </date>
                            
                            <div class="post-content">
                                一般 git 提供了 HTTPS 和 SSH（Secure Shell） 两种认证方式。HTTPS 比较简单，只需要输入对应的 user 和 password 就可以了。SSH 则相对复杂一点，需要使用 ssh 命令生成 RSA 密钥对，将 public key 提交到服务器，本地保留 private key。SSH 还可以允许我们通过 config 来管理多用户，例如：一般我们会有一个自己的 github 账户，通过 SSH 管理；同时，公司可能会有一个另外的源码管理平台，如 gitlab 或 gitee 等，一些公司还会在 gitlab 上搭建自有服务器。SSH 如何生成密钥对，如何通过 config 管理，这里就不做过多赘述了，网上随便一搜或者 github 中都有详细的说明：）
SSH 的 config 格式一般如下：
Host # 登陆主机的别名 HostName # 服务器的真实地址 Identityfile # 私钥目录  在前不久，上班摸鱼逛 v2ex 的时候，看见一个人发了一个帖子：
在上家公司的时候，我也遇到了同样的问题。每次重启 iTerm2 或者电脑，再 pull 或者 push 代码，就提示要输入密码，无论输入什么密码都提示错误。我一度以为是我人品问题，后来一阵摸索瞎试之后，将 Host 改成 HostName 相同的，就可以解决了。也就是说，如果你公司源码管理平台的地址是 gitlab.xxx.xxx，只需要将 Host 和 HostName 一起改成这个，就可以了。……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/git%E4%BD%BF%E7%94%A8ssh%E9%85%8D%E7%BD%AE%E4%B8%80%E7%9B%B4%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%9A%84%E5%9D%91/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Mac快捷键" >Mac快捷键</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月8日
                            </date>
                            
                            <div class="post-content">
                                Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的官方文档里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。
这些快捷键在 Mac 里面是通用的，也就意味着在几乎所有的有文本输入的地方，都可以用得上，一次学习，使用Anywhere :)。要熟悉掌握这些组合，还是要下一定功夫勤加练习的，不然右手又会不自觉地去触摸鼠标了。不过还是有一定技巧的，主要是掌握 ctl、shift、fn 的组合而已。
（强烈建议大家将键盘上的大小写切换键改为 ctl 键，因为 ctl 的作用远比大小写切换重要多了，大小写切换完全可以使用 shift + 字母的方式进行输入，但大小写键在键盘上却占据了很重要的位置，ctl缩在角落瑟瑟发抖）。修改方法：系统设置 -&gt; 键盘 -&gt; 修饰键（在右下角）-&gt; 大写锁定键改为 Control
光标移动 cmd + ← 移动至行首
cmd + → 移动至行尾
fn + ↓ 向下翻页
fn + ↑ 向上翻页
option + ← 向前跳一个词
option + → 向后跳一个词
ctl + p 光标向上移动一行
ctl + n 光标向下移动一行
ctl + b 光标向前移动一个字母
ctl + f 光标向后移动一个字母
ctl + e 光标移动到行尾……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/what-s-new-in-xcode11/" title="What&#39;s New in Xcode11" >What&#39;s New in Xcode11</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月5日
                            </date>
                            
                            <div class="post-content">
                                WWDC19 - What&rsquo;s New in Xcode11 WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 WWDC 2019 Session 401，顺便做一下记录。
首先，对 Xcode11 的整体改进做一个预览：
整体的改变还是挺多的，下面一一对改进的功能进行说明。
右上角功能键的改进 首先，Xcode 11 改变的是右上角的按钮，Xcode 10 上是三个按钮，到了 11 已经变成了两个按钮：原先的 Source Control Log 被移到了右侧栏里面：
原先的比较常用的切换 Assitant Editor 和 Authors 一起并入到了 Editor Options 里面，并将 Editor Options 移到了每个独立的编辑窗口里面：
上面 Xcode 11 的 Assistant 就是原先 Xcode 10 右上角的那两个圈圈
Editor Options 中同时新增了一个 Swift UI 的预览，当项目中使用到了 Swfit UI 的时候，可以预览 Swift UI 的效果……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/what-s-new-in-xcode11/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/cordova-in-ios/" title="Cordova in iOS" >Cordova in iOS</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。
环境搭建 安装Cordova:
sudo npm install -g cordova  如果提示错误，检查是否安装 Node.js
创建项目 创建工程项目：
cordova create Cordova com.example.CordovaTest CordovaTest  第一个参数为工程文件夹 第二个参数为应用的的 id 名，和 Xcode 中的 bundle Id 类似 第三个参数为工程名字
添加 iOS 平台支持
进入刚刚创建的工程目录下，执行：
cordova platform add ios  执行这个命令只出现光标没有反应的话，是因为网络原因。由于国内的网络环境，虽然的 npm 官方站点 http://www.npmjs.org/ 并没有被墙，但是下载第三方依赖包的速度有时还是不理想，我们可以改用淘宝的 NPM 镜像。
打开 ~/.npmrc 文件：
vim ~/.npmrc  添加以下内容：
registry = https://registry.npm.taobao.org  保存退出，再执行命令就会发现很快就配置好了。
打开 platforms/ios 目录，就可以运行我们的创建的工程了。……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/cordova-in-ios/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/ios%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" title="iOS 事件拦截" >iOS 事件拦截</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。
iOS事件机制 iOS 中的事件分为三类：触摸事件（单点、多点、手势），传感器事件（加速传感器）和远程控制事件（官方文档），我们遇到情况是第一种也就是触摸事件的机制。
响应者链 当一个事件发生时，如果 first responder 不做处理，那么就会往下传递，如果下一个 responder 也不处理，那么就会继续传递到再下一个 responder 中，直到有一个 responder 处理或者没有 responder 了，如果没有 responder 处理这个事件，那么这个事件就被抛弃了。这些 responder 按照传递顺序连接起来就构成了响应者链。
iOS 中的响应者链： 从图中我们可以观察到，响应者链有以下几个特点：
 响应者链通常由 initial view 开始。
 View 的 nextResponder 是它的 superView，如果 View 已经是它所在的 ViewController 中的 top view，那么 next responder 就是它所在的 ViewConTroller。
 ViewController 如果有 superViewController，那么它的 nextResponder 就是它superViewController 最上面的 View。如果没有，那么它的 nextResponder 就是 Window。
 Window 的 nextResponder 指向 Application，Application 是整个响应者链的顶层，它的 nextResponder 指向 nil。也就是说当事件传递到 Application 不被处理的话就会被抛弃了。……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/ios%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/opengl-es%E6%95%99%E7%A8%8B%E4%B8%80-%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6-/" title="OpenGL实战(一) - 简单图形绘制" >OpenGL实战(一) - 简单图形绘制</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                在上一篇文章中我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码+知识点+API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我（评论采用disqus，如果加载不出来，翻个墙试一下，联系方式见关于我）。
渲染屏幕==== 首先，将控制器继承自GLKViewController，并初始化一个GLKView，设置为它的View：
// 直接把上篇文章的初始化方法copy过来 // 创建一个上下文，并设置为当前上下文 EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; [EAGLContext setCurrentContext:context]; // 使用代码初始化 // GLKView *view = [GLKView alloc] initWithFrame:self.view.bounds context:context // 使用Storyboard初始化 GLKView *view = (GLKView *)self.view; view.context = context; // 关联上下文  只需在GLKView的代理方法(void)glkView:(GLKView *)view drawInRect:(CGRect)rect中，调用glClear的系列函数就可以用OpenGL ES对屏幕进行渲染了：
- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect { glClearColor(1, 0, 0, 1); // 清理屏幕的RGB颜色和alpha值，这里我们设置成了红色 glClear(GL_COLOR_BUFFER_BIT); // 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区 }  现在来做一个酷炫的效果，让屏幕显示闪烁。当设置GLKViewController代理的时候，每一帧动画GLKViewController都会告诉我们，它会在1秒内多次调用draw方法，GLKViewController的代理中，我们可以在GLKViewController的代理方法(void)glkViewControllerUpdate:(GLKViewController *)controller方法来更新屏幕的颜色。
首先定义两个参数并初始化:
@property (nonatomic, assign) CGFloat redColorFloat; // RGB中红色的色值 @property (nonatomic, assign, getter=isIncreasing) BOOL increasing; // 判断是否增加 self.……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/opengl-es%E6%95%99%E7%A8%8B%E4%B8%80-%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6-/">阅读全文</a></p>
                        </article>
                    
                    
		    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="http://superchun.cn/posts/%E5%88%9D%E8%AF%86opengl-es/" title="初识 OpenGL ES" >初识 OpenGL ES</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！
什么是OpenGL ES  OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。
OpenGL ES是从OpenGL裁剪定制而来的，去除了glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性。经过多年发展，现在主要有两个版本，OpenGL ES 1.x针对固定管线硬件的，OpenGL ES 2.x针对可编程管线硬件。OpenGL ES 1.0是以OpenGL 1.3规范为基础的，OpenGL ES 1.1是以OpenGL 1.5规范为基础的，它们分别又支持common和common lite两种profile。lite profile只支持定点实数，而common profile既支持定点数又支持浮点数。OpenGL ES 2.0则是参照OpenGL 2.0规范定义的，common profile发布于2005-8，引入了对可编程管线的支持。OpenGL ES 3.0于2012年公布，加入了大量新特性。 - - - - 维基百科
 苹果官方文档中对于OpenGL ES的描述为： OpenGL ES让App拥有了利用底层图形处理器的能力，iOS设备上的GPU可以执行复杂的2D和3D绘图，以及在最终图像上的每个像素的复杂着色计算。OpenGL ES是低级的、以硬件为中心的基于C的API，可以与iOS应用无缝集成。OpenGL ES规范没有定义窗口层，取而代之，当有任何绘图命令写入，主机操作系统必须定义一个方法来创建OpenGL ES渲染上下文，用来接受命令和帧缓冲。
OpenGL ES基本概念 坐标系
 由于OpenGL ES可以用来绘制2D和3D图形，所以它的坐标是一个三维坐标，如果应用只涉及到2D，那么可以不考虑Z轴。
纹理坐标
 一般OpenGL ES中的纹理坐标都是二维的，原点在左下角，与计算机中的图像坐标并不一致，二者的差别在于围绕横轴翻转180°。
顶点数据&amp;&amp;索引
顶点数据是一个数组，里面存的是顶点坐标。而索引则是顶点数组的对应的索引和串联关系。
// 顶点数据 GLFloat squareVertexData[] = { 0.5, -0.5, 0.0, //x,y,z -0.……
                            </div>
                            <p class="readmore"><a href="http://superchun.cn/posts/%E5%88%9D%E8%AF%86opengl-es/">阅读全文</a></p>
                        </article>
                    
                    
                    





                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="/search/" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://superchun.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://superchun.cn/posts/%E4%BB%8Eheapsort%E4%B8%8Emergesort%E7%9C%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="从Heapsort与Mergesort看排序算法">从Heapsort与Mergesort看排序算法</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/%E5%A6%82%E4%BD%95%E7%94%A8v2ray%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" title="如何用V2Ray科学上网">如何用V2Ray科学上网</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/git%E4%BD%BF%E7%94%A8ssh%E9%85%8D%E7%BD%AE%E4%B8%80%E7%9B%B4%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%9A%84%E5%9D%91/" title="git使用SSH配置一直需要输入密码的坑">git使用SSH配置一直需要输入密码的坑</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Mac快捷键">Mac快捷键</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/what-s-new-in-xcode11/" title="What&#39;s New in Xcode11">What&#39;s New in Xcode11</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/cordova-in-ios/" title="Cordova in iOS">Cordova in iOS</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/ios%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" title="iOS 事件拦截">iOS 事件拦截</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/opengl-es%E6%95%99%E7%A8%8B%E4%B8%80-%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6-/" title="OpenGL实战(一) - 简单图形绘制">OpenGL实战(一) - 简单图形绘制</a>
    </li>
    
    <li>
        <a href="http://superchun.cn/posts/%E5%88%9D%E8%AF%86opengl-es/" title="初识 OpenGL ES">初识 OpenGL ES</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="http://superchun.cn/tags/cordova/">Cordova</a>
    
    <a href="http://superchun.cn/tags/git-ssh/">git ssh</a>
    
    <a href="http://superchun.cn/tags/ios/">iOS</a>
    
    <a href="http://superchun.cn/tags/opengl-es/">OpenGL ES</a>
    
    <a href="http://superchun.cn/tags/%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/">事件拦截</a>
    
    <a href="http://superchun.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="http://superchun.cn/tags/%E6%9D%82%E8%B0%88%E4%BD%8E%E8%AF%AD/">杂谈低语</a>
    
    <a href="http://superchun.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/">科学上网</a>
    
    <a href="http://superchun.cn/tags/%E7%AE%97%E6%B3%95/">算法</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://superchun.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://superchun.cn">悉达多｜PainMaker By 悉达多</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>





</body>
</html>
