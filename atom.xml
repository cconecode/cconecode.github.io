<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悉达多｜Pain Maker</title>
  
  <subtitle>知也者，所以知也，而不必知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://superchun.cn/"/>
  <updated>2019-11-29T07:48:20.911Z</updated>
  <id>http://superchun.cn/</id>
  
  <author>
    <name>悉达多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用V2Ray科学上网</title>
    <link href="http://superchun.cn/how-to-freedom.html"/>
    <id>http://superchun.cn/how-to-freedom.html</id>
    <published>2019-11-29T06:06:21.000Z</published>
    <updated>2019-11-29T07:48:20.911Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是-v2ray">什么是 V2Ray</span></h2><p>想要通过 V2Ray 科学上网，先得了解 V2Ray 是什么。根据 V2Ray 指南比较官方的描述：</p><blockquote><p>V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。 官方中介绍Project V 提供了单一的内核和多种界面操作方式。内核（V2Ray）用于实际的网络交互、路由等针对网络数据的处理，而外围的用户界面程序提供了方便直接的操作流程。</p></blockquote><p>简单点说，V2Ray 就是一个跟 Shadowsocks 差不多的代理软件，可以让我们科学上网。只不过相对来说，V2Ray 功能更强大一点，同时配置也更复杂一点。而且鉴于现在走 SS 协议的代理基本都会受到干扰，科学上网起来也没那么流畅，这时候就需要了解及配置一套自己的 V2Ray了。V2Ray 更加稳定，而且传输速度相对 SS 也更快一点。</p><h2><span id="搭建-v2ray-需要什么">搭建 V2Ray 需要什么</span></h2><p>首先，简单的 V2Ray 只需要一台墙外的 VPS 就可以了，同时也需要一点 Linux 系统的知识。VPS 的话香港、日本、新加坡、美国的都行。只不过是延迟的差异而已，地理位置越靠近国内的延迟越低。在搬瓦工、Vlutr、DigitOcean 都可以买到对应的 VPS，其中搬瓦工是最出名的，也是最多人购买的，比较推荐。只不过如果你的 IP 不幸被封，需要 8 美刀更换一个 IP，而且搬瓦工一般都是按年付费的。Vlutr 则是我之前用的比较多的一家平台，可以免费更换 IP，被封了随时可以新建实例，而且是按时按月收费的，如果大环境不太爽畅，可以用 Vlutr 过度一下。它的缺点就是比较不稳定，配置相对也没有那么好。DigitOcean 我没有用过，所以就不做评价了。</p><p>但是，如果你很幸运的拥有一个 Google 账号，则可以通过 GoogleCloud 新用户的规则白嫖一年 VPS（<del>我现在就白嫖着～</del>）。GoogleCloud 会赠送新用户 300 美刀，可以使用其下面的云产品，300 美刀在一年之内需用完，过期作废。但国内用户开通 GoogleCloud 会比较麻烦，首先你得已经番羽墙了，然后要拥有一个境外的双币卡，才能完成新用户的认证。不过，有一个解决办法就是通过 P 卡去开通（P 卡：<a href="http://payoneer.com" target="_blank" rel="noopener">Payoneer</a>，一个虚拟信用卡网站），在知乎上有一篇文章，<a href="https://zhuanlan.zhihu.com/p/58747135" target="_blank" rel="noopener">新用户申请谷歌云300美金失败，怎么办？</a>，我就是通过这个方法申请开通成功的。然后就是注册实例之类的，就不再赘述了，网上都有许多相关的文章，随便找篇看看就知道怎么回事了。</p><p>当然，上面只是最简单的需要的东西。如果想更安全更稳定更快速的科学上网，就还需要一个域名，域名的作用是解析 VPS 主机，并通过它进行再次代理转发的。域名是个很便宜的东西，随便申请一个就好了，越便宜越好的那种。</p><blockquote><p><strong>个人建议：VPS 最好选择 Ubuntu 或者 Debain 系统的</strong></p></blockquote><h2><span id="前期准备">前期准备</span></h2><p>到了这一步，就默认上面所说的东西你都已经准备好了。现在开始前期的准备工作：</p><ol><li>将申请下来的 VPS 解析到申请好的域名</li><li>为域名申请 SSL 证书</li><li>安装 Nginx</li></ol><p>将 VPS 解析到申请好的域名就不做过多描述了，通过 DNSPod 或者申请域名的平台应该都可以进行解析。首先，登入到申请好的 VPS 上：</p><h3><span id="为域名申请-ssl-证书">为域名申请 SSL 证书</span></h3><p>我们可以通过 <a href="https://certbot.eff.org" target="_blank" rel="noopener">cerbot</a> 给域名生成对应的 SSL 证书：</p><h4><span id="1-下载并给-cerbot-赋予可执行权限">1. 下载并给 cerbot 赋予可执行权限</span></h4><p>首先，选择保存 cerbot 的目录，我们可以选择 <code>/usr/local/src</code>，cd 到想保存的目录。然后用 wget 命令下载 cerbot：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.eff.org/cerbot-auto</span><br></pre></td></tr></table></figure><p>然后再给 cerbot 赋予可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x cerbot-auto</span><br></pre></td></tr></table></figure><h4><span id="2-利用-cerbot-申请-lets-encry-证书">2. 利用 cerbot 申请 Let’s Encry 证书</span></h4><p>申请 Let’s Encry 证书需要以下几个条件：</p><ol><li>系统的 root 权限</li><li>443 端口未被占用，防火墙放行 443 端口，且外网能够直接访问本机的 443 端口</li><li>域名解析到了当前主机</li></ol><p>如果申请失败了，确认一下以上几点是否都满足。现在可以申请 SSL 证书了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto certonly</span><br></pre></td></tr></table></figure><p>第一次安装需要输入一些必要的信息，主要如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">How would  you like to authenticate with the ACME CA? </span><br><span class="line">--------------------------------------------------</span><br><span class="line">1: Spin up a temporary webserver (standalone)</span><br><span class="line">2: Place files in webroot directory (webroot)</span><br><span class="line">一般选择 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter email address (used for urgent renewal and security notices) (Enter 'c' to cancel): # 输入想使用的邮箱，用于接收证书到期等信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please enter in your domain name(s) (comma and/or space separated) (Enter 'c' to cancel): #输入想申请的域名</span><br></pre></td></tr></table></figure><p>申请成功之后，会有一个证书保存的路径显示，可以记录下来，后面需要用到。如果忘记了也没关系，证书一般都保存在 <code>/etc/letsencrypt/live/xxx</code>下面，在这里你可以找到申请好的证书，有你的域名的那两个文件就是对应的证书。</p><p>在证书快到期时，也可以通过下面的命令更新证书信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto renrew</span><br></pre></td></tr></table></figure><h3><span id="安装-nginx">安装 Nginx</span></h3><h4><span id="centos-系统添加-nginx-官方源">CentOS 系统添加 Nginx 官方源</span></h4><p>CentOS 系统官方源仓库文件在 <code>/etc/yum.repos.d</code>，只需要在下面新建一个文件保存 Nginx 的源就可以了，例如新建一个叫 <code>nginx.repo</code> 的文件，然后复制以下内容进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line"></span><br><span class="line">name=nginx repo</span><br><span class="line"><span class="meta">#</span> 下面的 OS 用实际发行版替换，如 centos 或 rhel，OSRELEASE 用具体发行版本号代替，如 6 或者 7。也就是说如果是 CentOS6，则需要将 OS/OSRELEASE 替换成 centos/6</span><br><span class="line">baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>保存文件后，就可以直接安装 Nginx 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><h4><span id="ubuntu-及-debain-系统添加官方源">Ubuntu 及 Debain 系统添加官方源</span></h4><p>用编辑器打开 <code>/etc/apt/sources.list</code>，Debain 添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://nginx.org/packages/debian/ codename nginx</span><br><span class="line">deb-src http://nginx.org/packages/debian/ codename nginx</span><br></pre></td></tr></table></figure><p>Ubuntu 添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://nginx.org/packages/ubuntu codename nginx</span><br><span class="line">deb-src http://nginx.org/packages/ubuntu codename nginx</span><br></pre></td></tr></table></figure><p>用命令 <code>cat/etc/os-release</code> 查询到实际发行版本号，替换上面内容中的 <code>codename</code>。</p><p>添加完上面内容后，还需要添加 Nginx 官方的 Key，不然会提示 Key 错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/keys/nginx_signing.key -O /tmp/nginx_signing.key</span><br><span class="line">apt-key add /tmp/nginx_signing.key</span><br></pre></td></tr></table></figure><p>最后先更新仓库源信息再安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure><p>到了这里，前期的准备工作基本完成了，下面则需要进入配置环节了。</p><h2><span id="安装-v2ray">安装 V2Ray</span></h2><p>用官方提供的命令一键安装 V2Ray：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><h2><span id="配置-v2ray">配置 V2Ray</span></h2><p>V2Ray 的配置文件放在 <code>/etc/V2Ray/config.json</code>，修改之前先备份一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/V2Ray/config.json /etc/V2Ray/config.json.bak</span><br></pre></td></tr></table></figure><p>在原先的默认配置中，修改或者添加下面的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"inbound"</span>:[&#123;</span><br><span class="line">   "port": 1000, # 设置 websocket 的端口号，用于和 Nginx 通信</span><br><span class="line">    "protocol": "vmess", # 选择 vmess 协议</span><br><span class="line">    "streamSettings":&#123;</span><br><span class="line">    "network":"ws",</span><br><span class="line">    "wsSettings":&#123;</span><br><span class="line">    "connectionReuse": false,</span><br><span class="line">    "path": "/ws", # Nginx 监听路径，后面 Nginx 设置及 V2Ray 客户端配置需要</span><br><span class="line">    "headers": &#123;</span><br><span class="line">    "Host": "申请的域名"</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置之后，可以用 V2Ray 自带的测试工具检测一下配置是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/V2Ray/V2Ray -test -config /etc/V2Ray/config.json</span><br></pre></td></tr></table></figure><h2><span id="配置-nginx-转发-websocket">配置 Nginx 转发 websocket</span></h2><p>在 <code>/etc/nginx/conf.d</code> 新建一个虚拟主机配置文件，内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 443 ssl;</span><br><span class="line">listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">ssl_certificate       # 第一步生成的 SSL 证书目录</span><br><span class="line">ssl_certificate_key  # 第一步生成的 SSL key 目录</span><br><span class="line">ssl_protocols   TLSv1 TLSv1.1 TLSv1.2</span><br><span class="line">ssl_ciphers    HIGH:!aNull:!MD5;</span><br><span class="line"></span><br><span class="line"># 域名</span><br><span class="line">server_name   xxxxx;</span><br><span class="line"></span><br><span class="line">location /ws &#123;</span><br><span class="line">proxy_redirect  off;</span><br><span class="line">proxy_pass  http://127.0.0.1:22125;  # V2Ray 配置的 websocket 端口</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header  Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header  Connection “upgrade”;</span><br><span class="line">proxy_set_header  Host $http_host;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root  /var/www/html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">listen [::]:80;</span><br><span class="line">server_name  xxxx; # 域名</span><br><span class="line">return 301 https://域名$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存之后用 Nginx 自带的配置文件检测功能检查下是否有问题：<code>nginx -t</code></p><p>没问题的话重启一下 V2Ray 和 Nginx 就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart V2Ray</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h2><span id="客户端的配置">客户端的配置</span></h2><p>其实 V2Ray 并没有所谓的客户端，它只是个配置而已，客户端的功能主要是保持和服务器的配置一样。Windows 上推荐的客户端是 V2RayW，Mac 上推荐的是 V2RayX，iOS 客户端推荐 Kitsunebi（需要在美区下载），Android 客户端推荐 V2RayNG。这里主要介绍一下 Mac 上 V2RayX 的配置，其他配置基本雷同。</p><p>V2RayX 的配置界面长这样：</p><p><img src="http://q0izzaygp.bkt.clouddn.com/2019-11-29-074008.png" alt="image-20191129152702069" style="zoom:50%;"></p><p>下面对各个功能及配置进行详细说明：</p><p><img src="http://q0izzaygp.bkt.clouddn.com/2019-11-29-074002.png" alt="image-20191129153014081" style="zoom:50%;"></p><p><img src="http://q0izzaygp.bkt.clouddn.com/2019-11-29-073955.png" alt="image-20191129153149501" style="zoom:50%;"></p><p><img src="http://q0izzaygp.bkt.clouddn.com/2019-11-29-073949.png" alt="image-20191129153413732" style="zoom:50%;"></p><p>到这里基本配置就完成了，接下来配置 websocket 和 TLS，点击配置中的 <code>transport settings...</code>，进入到：</p><p><img src="http://q0izzaygp.bkt.clouddn.com/2019-11-29-074227.png" alt="image-20191129154226871" style="zoom:50%;"></p><p><img src="http://q0izzaygp.bkt.clouddn.com/2019-11-29-074344.png" alt="image-20191129154343698" style="zoom:50%;"></p><p>到这里，客户端的配置也就已经完成了，可以愉快的科学上网了：)</p><p>如果，你并不想做那么复杂的配置，只想简单的科学上网，则只需要使用 V2Ray 默认生成的配置文件，将客户端的 id 及传输类型，配置成跟服务器中的一样就可以了。初次配置 V2Ray 会有点懵圈，因为它并不像 SS 一样，有严格的客户端功能配置，它只是一系列的配置文件而已，inbound 和 outbound 只是出站跟入站的配置，客户端也就是我们上网是 inbound，服务器则是 outbound。理清这些概念，就可以解决 V2Ray 中大部分的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;什么是-v2ray&quot;&gt;什么是 V2Ray&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;想要通过 V2Ray 科学上网，先得了解 V2Ray 是什么。根据 V2Ray 指南比较官方的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;V2Ray 是 Project V 下的
      
    
    </summary>
    
    
      <category term="科学上网" scheme="http://superchun.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>git使用SSH配置一直需要输入密码的坑</title>
    <link href="http://superchun.cn/git%E4%BD%BF%E7%94%A8SSH%E9%85%8D%E7%BD%AE%E4%B8%80%E7%9B%B4%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%9A%84%E5%9D%91.html"/>
    <id>http://superchun.cn/git使用SSH配置一直需要输入密码的坑.html</id>
    <published>2019-11-28T02:07:07.000Z</published>
    <updated>2019-11-28T02:49:54.714Z</updated>
    
    <content type="html"><![CDATA[<p>一般 git 提供了 HTTPS 和 SSH（Secure Shell） 两种认证方式。HTTPS 比较简单，只需要输入对应的 user 和 password 就可以了。SSH 则相对复杂一点，需要使用 ssh 命令生成 RSA 密钥对，将 public key 提交到服务器，本地保留 private key。SSH 还可以允许我们通过 config 来管理多用户，例如：一般我们会有一个自己的 github 账户，通过 SSH 管理；同时，公司可能会有一个另外的源码管理平台，如 gitlab 或 gitee 等，一些公司还会在 gitlab 上搭建自有服务器。<em>SSH 如何生成密钥对，如何通过 config 管理，这里就不做过多赘述了，网上随便一搜或者 github 中都有详细的说明：）</em></p><p>SSH 的 config 格式一般如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host # 登陆主机的别名</span><br><span class="line">HostName # 服务器的真实地址</span><br><span class="line">Identityfile # 私钥目录</span><br></pre></td></tr></table></figure><p>在前不久，<del>上班摸鱼</del>逛 v2ex 的时候，看见一个人发了一个帖子：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9djh01xtcj316m0n6dli.jpg" alt="image-20191128102137393" style="zoom:50%;"></p><p>在上家公司的时候，我也遇到了同样的问题。每次重启 iTerm2 或者电脑，再 pull 或者 push 代码，就提示要输入密码，无论输入什么密码都提示错误。我一度以为是我人品问题，后来一阵摸索<del>瞎试</del>之后，将 Host 改成 HostName 相同的，就可以解决了。也就是说，如果你公司源码管理平台的地址是 gitlab.xxx.xxx，只需要将 Host 和 HostName 一起改成这个，就可以了。</p><p>再回过头来看看，config 中的 Host 和 HostName，Host 是指主机别名，HostName 是指向真实地址。也就是说如果服务器的别名是 test，真实 IP 地址是 0.0.0.0，只需要将 Host 配置成 test，HostName 指向 0.0.0.0，然后再配合本地私钥就可以登陆上去访问了。但在实际中，公司搭建自有主机的时候，其实际主机别名跟其实际地址指向是一样的。如果是搭建在 gitlab 中，如果只在 config 中将 Host 指向 gitlab，那么就会出现一直需要密码的情况，只能重新生成密钥对去进行一次性的访问。</p><p>希望这篇文章能解决你在 SSH 使用过程中出现的类似的问题：），Have a good day！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般 git 提供了 HTTPS 和 SSH（Secure Shell） 两种认证方式。HTTPS 比较简单，只需要输入对应的 user 和 password 就可以了。SSH 则相对复杂一点，需要使用 ssh 命令生成 RSA 密钥对，将 public key 提交到服务
      
    
    </summary>
    
    
      <category term="git ssh" scheme="http://superchun.cn/tags/git-ssh/"/>
    
  </entry>
  
  <entry>
    <title>Mac快捷键</title>
    <link href="http://superchun.cn/Mac%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
    <id>http://superchun.cn/Mac快捷键.html</id>
    <published>2019-11-08T06:26:02.000Z</published>
    <updated>2019-11-08T07:06:56.320Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">官方文档</a>里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。</p><a id="more"></a><p>这些快捷键在 Mac 里面是通用的，也就意味着在几乎所有的有文本输入的地方，都可以用得上，一次学习，使用Anywhere :)。要熟悉掌握这些组合，还是要下一定功夫勤加练习的，不然右手又会不自觉地去触摸鼠标了。不过还是有一定技巧的，主要是掌握 <code>ctl</code>、<code>shift</code>、<code>fn</code> 的组合而已。</p><p><strong><em>（强烈建议大家将键盘上的大小写切换键改为 <code>ctl</code> 键，因为 <code>ctl</code> 的作用远比大小写切换重要多了，大小写切换完全可以使用 <code>shift</code> + 字母的方式进行输入，但大小写键在键盘上却占据了很重要的位置，<code>ctl</code>缩在角落瑟瑟发抖）。修改方法：系统设置 -&gt; 键盘 -&gt; 修饰键（在右下角）-&gt; 大写锁定键改为 Control</em></strong></p><h2><span id="光标移动">光标移动</span></h2><p><code>cmd</code> + <code>←</code>      移动至行首</p><p><code>cmd</code> + <code>→</code>      移动至行尾</p><p><code>fn</code> + <code>↓</code>        向下翻页</p><p><code>fn</code> + <code>↑</code>        向上翻页</p><p><code>option</code> + <code>←</code>    向前跳一个词</p><p><code>option</code> + <code>→</code>     向后跳一个词</p><p><code>ctl</code> + <code>p</code>     光标向上移动一行</p><p><code>ctl</code> + <code>n</code>     光标向下移动一行</p><p><code>ctl</code> + <code>b</code>     光标向前移动一个字母</p><p><code>ctl</code> + <code>f</code>      光标向后移动一个字母</p><p><code>ctl</code> + <code>e</code>      光标移动到行尾</p><p><code>ctl</code> + <code>a</code>      光标移动到行首</p><h2><span id="选取">选取</span></h2><p><code>option</code> + <code>shift</code> + <code>←</code>     向前选中一个单词</p><p><code>option</code> + <code>shift</code> + <code>→</code>     向后选中一个单词</p><p><code>cmd</code> + <code>shift</code> + <code>→</code>        从当前光标选中到行尾</p><p><code>cmd</code> + <code>shift</code> + <code>←</code>         从当前光标选中到行首</p><h2><span id="删除">删除</span></h2><p><code>fn</code> + <code>delete</code>      向后删除</p><p><code>option</code> + <code>delete</code>     向前删除一个单词</p><p><code>fn</code> + <code>option</code> + <code>delete</code>     向后删除一个单词</p><p><code>cmd</code> + <code>delete</code>     从当前光标删除到行首</p><p><code>fn</code> + <code>cmd</code> + <code>delete</code>     从当前光标删除到行尾</p><h2><span id="snap">Snap</span></h2><p>最后，也推荐给大家一个软件 <strong><code>Snap</code></strong>，在 AppStore 可以直接下载。这个软件的作用是绑定应用快捷键的，可以把对应的应用绑定成自己喜欢的快捷键，通过快捷键快速启动和切换应用，时间复杂度是 <em>O(1)</em>，远比用 <code>cmd</code> + <code>tab</code>（时间复杂度 <em>O(n)</em>）或者用鼠标点击（时间复杂度 <em>O(n^2)</em>）快多了</p><p>软件主界面长这样：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8qmrx1xtgj30nm0mq47h.jpg" alt="image-20191108144757647" style="zoom:50%;"></p><p>这个主要是设置默认快捷键的，比如这里设置了 <code>ctl</code> + <code>cmd</code>，那么你就可以通过 <code>ctl</code> + <code>cmd</code> + <code>1</code>  的快捷键来启动或者切换 Dock 上的第一个应用，<code>ctl</code> + <code>cmd</code> + <code>2</code> 启动或者切换第二个，以此类推。</p><p>上面这种方法不是很建议，因为需要记住应用在 Dock 上的位置或者自己手动排列 Dock 位置。还有另外一种方法就是 <code>Manual</code>，就是上面说的应用绑定快捷键，界面长这样：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8qmwfl0kaj30nm0mq0xz.jpg" alt="image-20191108145217899" style="zoom:50%;"></p><p>点击左下角就可以选择一个应用，然后输入对应的快捷键，后面就可以愉快的玩耍了 ^-^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的&lt;a href=&quot;https://support.apple.com/zh-cn/HT201236&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈低语" scheme="http://superchun.cn/tags/%E6%9D%82%E8%B0%88%E4%BD%8E%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in Xcode11</title>
    <link href="http://superchun.cn/What-s-New-in-Xcode11.html"/>
    <id>http://superchun.cn/What-s-New-in-Xcode11.html</id>
    <published>2019-11-05T07:38:21.000Z</published>
    <updated>2019-11-05T12:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="wwdc19-whats-new-in-xcode11">WWDC19 - What’s New in Xcode11</span></h1><p>WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 <a href="https://developer.apple.com/videos/play/wwdc2019/401/" target="_blank" rel="noopener">WWDC 2019 Session 401</a>，顺便做一下记录。</p><a id="more"></a><p>首先，对 Xcode11 的整体改进做一个预览：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n98whgi4j30wc0ha7fe.jpg" alt="preview"></p><p>整体的改变还是挺多的，下面一一对改进的功能进行说明。</p><h2><span id="右上角功能键的改进">右上角功能键的改进</span></h2><p>首先，Xcode 11 改变的是右上角的按钮，Xcode 10 上是三个按钮，到了 11 已经变成了两个按钮：<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9nrz958j30ee03gq32.jpg" alt="image-20191105165729690" style="zoom:50%;">             <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9mwnaxgj30cc03iweo.jpg" alt="image-20191105165639942" style="zoom:50%;">     </p><p>原先的 Source Control Log 被移到了右侧栏里面：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9p9xusdj30ec05ktam.jpg" alt="image-20191105165856444" style="zoom:50%;">             <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9qc8ozdj30ee054dg7.jpg" alt="image-20191105165958024" style="zoom:50%;"></p><p>原先的比较常用的切换 Assitant Editor 和 Authors 一起并入到了 Editor Options 里面，并将 Editor Options 移到了每个独立的编辑窗口里面：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9wj9q5yj30ec05uwgf.jpg" alt="image-20191105170554608" style="zoom:50%;">              <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9x9yx7vj30a00bgdlp.jpg" alt="image-20191105170637216" style="zoom:50%;">                   </p><p><em>上面 Xcode 11 的 Assistant 就是原先 Xcode 10 右上角的那两个圈圈</em></p><p>Editor Options 中同时新增了一个 Swift UI 的预览，当项目中使用到了 Swfit UI 的时候，可以预览 Swift UI 的效果</p><p>现在 Xcode 11 上面的两个按钮的功能变成了 Library 和 Code Review：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8na7koerqj30b203iwex.jpg" alt="image-20191105171631101"></p><p>Library 的主要功能是：选择 IB 控件、文档、代码块、图片资源以及颜色</p><p>Code Review 的主要功能是：比较同一源文件源码的改动</p><h2><span id="editor-splitting">Editor Splitting</span></h2><p>在 Xcode 11 里面，增加了一个 Editor Spliting 的功能，可以随时随地的增加一个 Editor：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8na1dqbffj307c0460sm.jpg" alt="image-20191105171034560"></p><p>Editor Spliting 默认的是往右边增加，按住 option 键再点击这个按钮，就可以在下面增加新的 Editor</p><p>可以通过按住 shift + option 并点击源文件，来管理 Editor，点击的源文件那个窗口会变成选中效果，可以用鼠标或者键盘方向键进行移动，移动完成后，点击键盘上的 return，原先选中的源文件就会插入或者移动到当前位置</p><h2><span id="minimap">Minimap</span></h2><p>Xcode 11 比较大的一个改动就是新增了 Minimap：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8napo7hbsj309w0lmjxt.jpg" alt="image-20191105173354397" style="zoom:50%;"></p><p>Minimap 主要是提供导航作用的，点击 Minimap 的任意位置，源码便会滚动到点击的地方。 当鼠标悬停在上面时，会显示当前的方法名：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8naszwn6tj30h40l0mxq.jpg" alt="image-20191105173706542" style="zoom:50%;"></p><p>同时按住 cmd 键的话，会显示当前所有的方法名：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nau5ip8rj30so0zi461.jpg" alt="image-20191105173813596" style="zoom:33%;"></p><p>当源码中有 warning 或者断点时，在 Minimap 中也会显示</p><p>源码中的 marks 在 Minimap 里可以直接看到：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nawlhq2ej307w0isglu.jpg" alt="image-20191105174034623" style="zoom:50%;"></p><p>当在源码中搜索关键字时，所有符合条件的在 Minimap 中会有选中效果：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nb0ed9c3j30860s8dgh.jpg" alt="image-20191105174413261" style="zoom:33%;"></p><h2><span id="源码-editor">源码 Editor</span></h2><p>Xcode 11 中通过 cmd + 右键点击方法名，可以给方法添加参数注释。新增了参数时，通过这个方法会自动拼接新的参数：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nbutwblij31he0b67en.jpg" alt="image-20191105181327456"></p><p>cmd + 右键点击参数，选择 Edit All in Scope，可以同时修改方法名、方法内、注释里面的参数名称：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nbwii6k1j314e08stb8.jpg" alt="image-20191105181504863"></p><p>当对源码进行了修改时，在 Editor 的左侧会出现一个蓝色条，点击这个蓝色条，可以选择 Show Change 和 Discard Change。Discard Change 的作用是撤销修改，Show Change 的作用是显示哪些地方进行了改动：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nc3aq6aqj30im06atdg.jpg" alt="image-20191105182136776" style="zoom:50%;"></p><p>除此之外，Xcode 11 还有着更好的自动补全、增加了新的 Theme，优化了一些细节体验</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WWDC19-What’s-New-in-Xcode11&quot;&gt;&lt;a href=&quot;#WWDC19-What’s-New-in-Xcode11&quot; class=&quot;headerlink&quot; title=&quot;WWDC19 - What’s New in Xcode11&quot;&gt;&lt;/a&gt;WWDC19 - What’s New in Xcode11&lt;/h1&gt;&lt;p&gt;WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2019/401/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2019 Session 401&lt;/a&gt;，顺便做一下记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://superchun.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Cordova in iOS</title>
    <link href="http://superchun.cn/Cordova.html"/>
    <id>http://superchun.cn/Cordova.html</id>
    <published>2016-09-07T16:00:00.000Z</published>
    <updated>2016-12-17T06:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。</p><h1><span id="环境搭建">环境搭建</span></h1><p>安装Cordova:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g cordova</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果提示错误，检查是否安装 Node.js</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建项目</span></span><br><span class="line"></span><br><span class="line">**创建工程项目：**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```ObjectiveC</span><br><span class="line">cordova create Cordova com.example.CordovaTest CordovaTest</span><br></pre></td></tr></table></figure><p>第一个参数为工程文件夹<br>第二个参数为应用的的 id 名，和 Xcode 中的 bundle Id 类似<br>第三个参数为工程名字</p><p><strong>添加 iOS 平台支持</strong></p><p>进入刚刚创建的工程目录下，执行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova platform add ios</span><br></pre></td></tr></table></figure><p>执行这个命令只出现光标没有反应的话，是因为网络原因。由于国内的网络环境，虽然的 npm 官方站点 <a href="http://www.npmjs.org/" target="_blank" rel="noopener">http://www.npmjs.org/</a> 并没有被墙，但是下载第三方依赖包的速度有时还是不理想，我们可以改用淘宝的 NPM 镜像。</p><p>打开 ~/.npmrc 文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.npmrc</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>保存退出，再执行命令就会发现很快就配置好了。</p><p>打开 platforms/ios 目录，就可以运行我们的创建的工程了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;环境搭建&quot;&gt;环境搭建&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;安装Cordova:&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="Cordova" scheme="http://superchun.cn/categories/Cordova/"/>
    
    
      <category term="Cordova" scheme="http://superchun.cn/tags/Cordova/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL实战(一) - 简单图形绘制</title>
    <link href="http://superchun.cn/OpenGLES-2.html"/>
    <id>http://superchun.cn/OpenGLES-2.html</id>
    <published>2016-08-30T16:00:00.000Z</published>
    <updated>2016-12-17T12:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://parisdog.club/OpenGLES-1.html" target="_blank" rel="noopener">上一篇文章中</a>我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码+知识点+API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我（评论采用disqus，如果加载不出来，翻个墙试一下，联系方式见关于我）。</p><h1><span id="渲染屏幕">渲染屏幕====</span></h1><p>首先，将控制器继承自GLKViewController，并初始化一个GLKView，设置为它的View：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接把上篇文章的初始化方法copy过来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个上下文，并设置为当前上下文</span></span><br><span class="line">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">[EAGLContext setCurrentContext:context];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    使用代码初始化</span></span><br><span class="line"><span class="comment">//    GLKView *view = [GLKView alloc] initWithFrame:self.view.bounds context:context</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    使用Storyboard初始化</span></span><br><span class="line">GLKView *view = (GLKView *)<span class="keyword">self</span>.view;</span><br><span class="line">view.context = context; <span class="comment">// 关联上下文</span></span><br></pre></td></tr></table></figure><p>只需在GLKView的代理方法<code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect</code>中，调用<code>glClear</code>的系列函数就可以用OpenGL ES对屏幕进行渲染了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 清理屏幕的RGB颜色和alpha值，这里我们设置成了红色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来做一个酷炫的效果，让屏幕显示闪烁。当设置GLKViewController代理的时候，每一帧动画GLKViewController都会告诉我们，它会在1秒内多次调用<code>draw</code>方法，GLKViewController的代理中，我们可以在GLKViewController的代理方法<code>(void)glkViewControllerUpdate:(GLKViewController *)controller</code>方法来更新屏幕的颜色。</p><p>首先定义两个参数并初始化:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> redColorFloat; <span class="comment">// RGB中红色的色值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isIncreasing) <span class="built_in">BOOL</span> increasing; <span class="comment">// 判断是否增加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.increasing = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.redColorFloat = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>设定GLKViewController的刷新频率:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.preferredFramesPerSecond = <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>更新<code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect</code>中的代码，在GLKViewController的代理方法中更新屏幕颜色:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="keyword">self</span>.redColorFloat, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 清理屏幕的RGB颜色和alpha值</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)glkViewControllerUpdate:(GLKViewController *)controller &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isIncreasing) &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat += <span class="number">1.0</span> * <span class="keyword">self</span>.timeSinceLastUpdate;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat -= <span class="number">1.0</span> * <span class="keyword">self</span>.timeSinceLastUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.redColorFloat &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">self</span>.increasing = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.redColorFloat &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.increasing = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了屏幕黑红闪烁效果，Demo可以在<a href="https://github.com/cconecode/OpenGLESTutorials/tree/master/Tutorial1-ScreenRendering" target="_blank" rel="noopener">这里</a>找到。</p><h1><span id="绘制图形">绘制图形</span></h1><p>现在我们来利用OpenGL ES绘制一个正方形。因为OpenGL ES只能渲染三角形，所以要用两个三角形来组成一个正方形。首先创建一组顶点数据和索引数据：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line">    GLfloat verties[] = &#123;</span><br><span class="line">        <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,  <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,   <span class="comment">// 前面为x, y, z, 后面为颜色</span></span><br><span class="line">        <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>,     <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line">        <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>,   <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,</span><br><span class="line">        <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>,    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引数据</span></span><br><span class="line">    GLuint indecs[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>顶点数据中包括了顶点位置和对应的颜色，索引数据则是顶点数组的索引。然后我们需要向OpenGL ES发送数据和缓存数据：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">glGenBuffers(<span class="number">1</span>, &amp;vertBuffer); <span class="comment">// 创建缓冲区对象</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vertBuffer); <span class="comment">// 指定当前活动缓冲区对象</span></span><br><span class="line">                                           <span class="comment">// GL_ARRAY_BUFFER 坐标，颜色等</span></span><br><span class="line">                                           <span class="comment">// GL_ELEMENT_ARRAY_BUFFER 索引坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把顶点数据从 CPU 复制到 GPU</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(verties), verties, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// glBufferData(&lt;#GLenum target#&gt;, &lt;#GLsizeiptr size#&gt;, &lt;#const GLvoid *data#&gt;, &lt;#GLenum usage#&gt;)</span></span><br><span class="line"><span class="comment">// target: 可以是GL_ARRAY_BUFFER(顶点数据)，或者GL_ELEMENT_ARRAY_BUFFER(索引数据)</span></span><br><span class="line"><span class="comment">// size: 存储相关数据所需要的内存容量</span></span><br><span class="line"><span class="comment">// data: 用于初始化缓冲区对象，可以是指向某一块内存地址，也可以是NULL</span></span><br><span class="line"><span class="comment">//usage: 数据分配后如何读写，详细介绍见：http://parisdog.club/OpenGLES-2.html</span></span><br><span class="line"></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;indeBuffer); <span class="comment">// 索引数据</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indeBuffer);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indecs), indecs, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>关于 usage 的一些说明：</p><ul><li>GL_STREAM_DRAW: 数据只指定一次，并且最多只有几次作为绘图和指定图像函数的源数据</li><li>GL_STREAM_READ: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次由应用程序作为数据值使用</li><li>GL_STREAM_COPY: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次作为绘图和指定图像函数的源数据</li><li>GL_STATIC_DRAW: 数据只指定一次，但是可以多次几次作为绘图和指定图像函数的源数据</li><li>GL_STATIC_READ:  数据从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用</li><li>GL_STATIC_COPY: 数据从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据</li><li>GL_DYNAMIC_DRAW: 数据可以多次指定，并且可以多次几次作为绘图和指定图像函数的源数据</li><li>GL_DYNAMIC_READ: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用 </li><li>GL_DYNAMIC_COPY: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据</li></ul><p>在OpenGL ES2.0当中，无论渲染什么图形，都必须用到着色器。着色器是用类C语言-GLSL语言写的，如果想要自定义一个着色器，那么学习这门语言十分有必要。现在<code>GLKBaseEffect</code>这个类为我们提供了一些通用的着色器，在还没有掌握GLSL的情况下，我们目前可以使用它来帮我们实现效果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义和初始化一个GLKBaseEffect实例对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) GLKBaseEffect *effect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.effect = [[GLKBaseEffect alloc] init];</span><br><span class="line"><span class="comment">// 可以设置 effect 的一些属性，配置光，转化等</span></span><br></pre></td></tr></table></figure><p>最后在代理方法中启动着色器:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动着色器</span></span><br><span class="line">    [<span class="keyword">self</span>.effect prepareToDraw];</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="keyword">self</span>.count, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以看到最终的效果了：</p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/09/01/57c7eec495cab.jpg" width="200" alt="最终效果"><br></div><p>细心观察就会发现，我们想要的结果是一个正方形，现在出来的效果却是一个矩形，这是为什么呢？因为默认的，“Effect”的投影矩阵是一个单位矩阵，它不做任何变换，将场景（-1，-1，-1）到（1，1，1）的立文体范围的物体，投射到屏幕的X：-1，1，Y：-1，1。因此，当屏幕本身是非正方形时，正方形的物体将被拉伸，从而显示为矩形。所以我们要在<code>update</code> 中修改投影矩阵：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)update &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.view.bounds.size;</span><br><span class="line">    <span class="keyword">float</span> aspect = fabs(size.width / size.height);</span><br><span class="line">    </span><br><span class="line">    GLKMatrix4 projectMartix =    GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span class="number">130.0</span>), aspect, <span class="number">0.1</span>, <span class="number">10.0</span>);</span><br><span class="line">    <span class="comment">// 第一个参数代表视角</span></span><br><span class="line">    <span class="comment">// 第二个参数代表比例</span></span><br><span class="line">    <span class="comment">// 第三个参数代表近平面距离</span></span><br><span class="line">    <span class="comment">// 第四个参数代表远平面距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.effect.transform.projectionMatrix = projectMartix;</span><br><span class="line">    </span><br><span class="line">    GLKMatrix4 modelMatrix =     GLKMatrix4Translate(GLKMatrix4Identity, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>); <span class="comment">// 修改 Z 轴的距离</span></span><br><span class="line">    <span class="keyword">self</span>.effect.transform.modelviewMatrix = modelMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过这段代码就能得到我们想要的结果了：一个正方形（Demo 在<a href="https://github.com/cconecode/OpenGLESTutorials" target="_blank" rel="noopener">这里</a>）。在学习过程中，踩了很多坑，包括一开始的图像显示不出来，API 的意思也不明确。后来通过 Google 查阅相关资料，把一些 bug 解决了，同时也加深了对 OpenGL ES 的理解，学习到了很多的东西。上面的知识，在代码中我已经注释的很清楚了，如果有不懂的地方或者不正确的地方，欢迎指正交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;http://parisdog.club/OpenGLES-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章中&lt;/a&gt;我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码
      
    
    </summary>
    
      <category term="OpenGL ES" scheme="http://superchun.cn/categories/OpenGL-ES/"/>
    
    
      <category term="OpenGL ES" scheme="http://superchun.cn/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>初识 OpenGL ES</title>
    <link href="http://superchun.cn/OpenGLES-1.html"/>
    <id>http://superchun.cn/OpenGLES-1.html</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-08-30T15:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！</p><h1><span id="什么是opengl-es">什么是OpenGL ES</span></h1><blockquote><p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。</p></blockquote><blockquote><p>OpenGL ES是从OpenGL裁剪定制而来的，去除了glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性。经过多年发展，现在主要有两个版本，OpenGL ES 1.x针对固定管线硬件的，OpenGL ES 2.x针对可编程管线硬件。OpenGL ES 1.0是以OpenGL 1.3规范为基础的，OpenGL ES 1.1是以OpenGL 1.5规范为基础的，它们分别又支持common和common lite两种profile。lite profile只支持定点实数，而common profile既支持定点数又支持浮点数。OpenGL ES 2.0则是参照OpenGL 2.0规范定义的，common profile发布于2005-8，引入了对可编程管线的支持。OpenGL ES 3.0于2012年公布，加入了大量新特性。              - - - - 维基百科</p></blockquote><p>苹果官方文档中对于OpenGL ES的描述为：<br>OpenGL ES让App拥有了利用底层图形处理器的能力，iOS设备上的GPU可以执行复杂的2D和3D绘图，以及在最终图像上的每个像素的复杂着色计算。OpenGL ES是低级的、以硬件为中心的基于C的API，可以与iOS应用无缝集成。OpenGL ES规范没有定义窗口层，取而代之，当有任何绘图命令写入，主机操作系统必须定义一个方法来创建OpenGL ES<code>渲染上下文</code>，用来接受命令和帧缓冲。</p><h1><span id="opengl-es基本概念">OpenGL ES基本概念</span></h1><p><strong>坐标系</strong></p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/08/29/57c3f86c6f12c.jpg" width="150" height="显示高度" alt="OpenGL ES坐标系"><br></div><p>由于OpenGL ES可以用来绘制2D和3D图形，所以它的坐标是一个三维坐标，如果应用只涉及到2D，那么可以不考虑Z轴。</p><p><strong>纹理坐标</strong></p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/08/29/57c3fcfd8bfc2.jpg" width="150" alt="纹理坐标系"><br></div><p>一般OpenGL ES中的纹理坐标都是二维的，原点在左下角，与计算机中的图像坐标并不一致，二者的差别在于围绕横轴翻转180°。</p><p><strong>顶点数据&amp;&amp;索引</strong></p><p>顶点数据是一个数组，里面存的是顶点坐标。而索引则是顶点数组的对应的索引和串联关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line">GLFloat squareVertexData[] = &#123;</span><br><span class="line">    <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="comment">//x,y,z</span></span><br><span class="line">    <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">GLuint indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面顶点数组里面的一行就代表了坐标系里面的x,y,z三个坐标系，代表了一个顶点的位置，里面总共包含了4个点。索引数组则是顶点数据的索引，每一行代表一个连接关系，从0-1-2，从1-3-0。</p><h1><span id="eaglcontext">EAGLContext</span></h1><p>在使用OpenGL ES之前，必须初始化一个EAGLContext对象，并且将它设置为当前上下文</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化EAGLContext</span></span><br><span class="line">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为当前上下文</span></span><br><span class="line">[EAGLContext setCurrentContext:context];</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>每个线程都会维护一个当前上下文。</li><li>设置了一个新的上下文，EAGL会释放当前上下文，并且获取新的上下文。</li><li>当在同一个线程中转换两个或者更多的上下文时，在设置一个新的上下文作为当前上下文之前，需要调用<code>glFlush</code>函数，确保之前的一些命令可以及时传递给图像硬件设备。</li></ul><p>调用<code>glFlush</code>函数时需导入<code>OpenGLES/ES2/gl.h</code>框架。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glFlush()</span><br></pre></td></tr></table></figure><h1><span id="glkview">GLKView</span></h1><p><strong>GLKView介绍</strong></p><p>GLKView管理着OpenGL ES的基础，来提供绘制代码的地方。GLKView提供了基于OpenGL ES并等效于标准UIView的绘图生命周期。一个UIView实例自动配置图像上下文，所以<code>drawRect:</code>只需执行Quartz 2D绘图命令，GLKView实例自动配置本身，所以你的绘图方法只需执行OpenGL ES命令。GLKView通过维护一个保存着OpenGL ES绘图命令的帧缓冲对象来实现这一功能，一旦你的绘图方法完成，就会自动把结果呈现给Core Animation。</p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/08/29/57c460e7a3f36.png" height="300" alt="通过GLKView渲染OpenGL ES内容"><br></div><p><strong>GLKView初始化方法</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">[EAGLContext setCurrentContext:context];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用代码初始化</span></span><br><span class="line"><span class="comment">//  GLKView *view = [GLKView alloc] initWithFrame:self.view.bounds context:context</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    使用Storyboard初始化</span></span><br><span class="line">GLKView *view = (GLKView *)<span class="keyword">self</span>.view;</span><br><span class="line">view.context = context; <span class="comment">// 关联上下文</span></span><br><span class="line">    </span><br><span class="line">view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; <span class="comment">// 颜色缓冲区格式</span></span><br><span class="line">view.drawableDepthFormat = GLKViewDrawableDepthFormat24; <span class="comment">// 深度缓冲区格式</span></span><br><span class="line">view.drawableStencilFormat = GLKViewDrawableStencilFormat8; <span class="comment">// 模型缓冲区格式</span></span><br><span class="line">view.drawableMultisample = GLKViewDrawableMultisample4X; <span class="comment">// 允许多重采样 (多重采样主要用于反锯齿，只对多边形的边缘进行抗锯齿处理，资源消耗较小，最常见的反锯齿), 如果允许了多重采样，必须测试性能</span></span><br></pre></td></tr></table></figure><p><strong>GLKViewDelegate</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染场景代码</span></span><br><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景数据变化</span></span><br><span class="line">- (<span class="keyword">void</span>)update &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLKView能够为OpenGL ES的绘制提供一个简单的界面，因为它管理着OpenGL ES渲染过程的部分标准：</p><ul><li>在调用绘图方法之前，视图：<ul><li>使<code>EAGLContext</code>为当前上下文</li><li>基于当前大小、比例因子和drawable属性（如果需要），创建帧缓冲对象和渲染缓冲区</li><li>将帧缓冲对象作为绘图命令的当前目标</li><li>设置OpenGL ES视图端口来匹配帧缓冲区大小</li></ul></li></ul><ul><li>绘图方法执行完后，视图：<ul><li>解析多重采样缓冲区（如果允许多重采样）</li><li>丢弃不需要的渲染缓冲区</li><li>将渲染缓冲区内容交给Core Animation缓存和显示</li></ul></li></ul><p>参考：<br>    <a href="https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1" target="_blank" rel="noopener">OpenGL ES Programming Guide for iOS </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！&lt;/p&gt;
&lt;h1&gt;&lt;span id
      
    
    </summary>
    
      <category term="OpenGL ES" scheme="http://superchun.cn/categories/OpenGL-ES/"/>
    
    
      <category term="OpenGL ES" scheme="http://superchun.cn/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>iOS 事件拦截</title>
    <link href="http://superchun.cn/iOSEvent.html"/>
    <id>http://superchun.cn/iOSEvent.html</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2016-08-30T14:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。</p><h1><span id="ios事件机制">iOS事件机制</span></h1><p>iOS 中的事件分为三类：触摸事件（单点、多点、手势），传感器事件（加速传感器）和远程控制事件（<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html" target="_blank" rel="noopener">官方文档</a>），我们遇到情况是第一种也就是触摸事件的机制。</p><h2><span id="响应者链">响应者链</span></h2><p>当一个事件发生时，如果 first responder 不做处理，那么就会往下传递，如果下一个 responder 也不处理，那么就会继续传递到再下一个 responder 中，直到有一个 responder 处理或者没有 responder 了，如果没有 responder 处理这个事件，那么这个事件就被抛弃了。这些 responder 按照传递顺序连接起来就构成了响应者链。</p><p>iOS 中的响应者链：<br><img src="https://lh3.googleusercontent.com/-6DVPdEbo12A/V48oTEjGXfI/AAAAAAAAAAk/Vn_s04cJOlk/I/14689996896970.jpg" alt="苹果官方关于响应者链的描述"></p><p>从图中我们可以观察到，响应者链有以下几个特点：</p><ul><li><p>响应者链通常由 initial view 开始。</p></li><li><p>View 的 nextResponder 是它的 superView，如果 View 已经是它所在的 ViewController 中的 top view，那么 next responder 就是它所在的 ViewConTroller。</p></li><li><p>ViewController 如果有 superViewController，那么它的 nextResponder 就是它superViewController 最上面的 View。如果没有，那么它的 nextResponder 就是 Window。</p></li><li><p>Window 的 nextResponder 指向 Application，Application 是整个响应者链的顶层，它的 nextResponder 指向 nil。也就是说当事件传递到 Application 不被处理的话就会被抛弃了。</p></li></ul><p>由于 UI 的复杂性，整个响应者链是需要通过计算的，而计算顺序基本是与响应者链分发相反的。<code>无论哪种事件，都是系统本身先获得，再交给 UIApplication，由 UIApplication 决定交给谁去处理。</code> 关于事件分发的计算网上有很多文章，我就不赘述了。通过上述了解，我们可以得出一个结论：<code>如果我们需要拦截一个事件，最好的机会是在 UIApplication 里面。</code></p><h1><span id="需求具体实现">需求具体实现</span></h1><h2><span id="oc-版">OC 版</span></h2><p>根据上面的结论，我们目前的思路是继承 UIApplication，然后实现某一方法，进行事件拦截。根据查阅资料，重写 UIApplication 的 <code>sendEvent</code>方法可以达到目的，sendEvent介绍如下：</p><blockquote><p> <strong>sendEvent:</strong></p></blockquote><blockquote><p>Dispatches an event to the appropriate responder objects in the application.</p></blockquote><blockquote></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure><blockquote><p> <strong>Parameters</strong><br>event<br>A UIEvent object encapsulating the information about an event, including the touches involved.</p></blockquote><blockquote><p><strong>Discussion</strong><br>Subclasses may override this method to intercept incoming events for inspection and special dispatching. iOS calls this method for public events only.</p></blockquote><p>具体代码实现：</p><ol><li>新建一个继承 UIApplication 的 CTApplication，重写 sendEvent 方法，并判断是否为触摸事件：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CTApplication.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTApplication</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.type == <span class="built_in">UIEventTypeTouches</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[event.allTouches anyObject] phase] == <span class="built_in">UITouchPhaseBegan</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> [<span class="keyword">super</span> sendEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>2.由于需要检测用户多长时间没有点击屏幕，需要加一个定时器来进行倒计时，设置定时器的方法写在 CTApplication 的 init 方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CTApplication.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 不点击屏幕的时间 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> showTime = <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTApplication</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTApplication</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setTimer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setTimer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:showTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(showPicture) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showPicture &#123;</span><br><span class="line"><span class="comment">/** 在这里对广告轮播图进行设置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.再回到 sendEvent 方法中，如果该方法被触发了，那么让定时器失效，重新开始定时：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> sendEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (event.type == <span class="built_in">UIEventTypeTouches</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[event.allTouches anyObject] phase] == <span class="built_in">UITouchPhaseBegan</span>) &#123;</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">            [<span class="keyword">self</span> setTimer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.最后，在 main 函数中还要做对应的更改，替换 UIApplication 的调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CTApplication.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]), <span class="built_in">NSStringFromClass</span>([<span class="built_in">CTApplication</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="swift版">Swift版</span></h2><p>首先新建一个 UIApplication 的子类 CTApplication：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTApplication</span>: <span class="title">UIApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sendEvent</span><span class="params">(event: UIEvent)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.sendEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Swift 中没有 main 函数，所以需要自己手动建一个 main 函数，并设置入口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="type">UIApplicationMain</span>(<span class="type">Process</span>.argc, <span class="type">Process</span>.unsafeArgv, <span class="type">NSStringFromClass</span>(<span class="type">CTApplication</span>), <span class="type">NSStringFromClass</span>(<span class="type">AppDelegate</span>))</span><br></pre></td></tr></table></figure><p>这时，Appdelegate 中的<code>@UIApplicationMain</code>会报错。下面是苹果官方对于<code>@UIApplicationMain</code>关键字的描述：</p><blockquote><p>Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class.</p></blockquote><blockquote><p>If you do not use this attribute, supply a main.swift file with a main function that calls the UIApplicationMain(::<em>:) function. For example, if your app uses a custom subclass of UIApplication<br>as its principal class, call the UIApplicationMain(::</em>:) function instead of using this attribute.</p></blockquote><p>意思就是在类的最顶部声明 <code>@UIApplicationMain</code>，表示该类是Application 的 delegate，另外一种做法就是在 main.Swift 中调用 UIApplicationMain 函数，设置 delegate 和 application。而我们采取的是后面的办法，所以 delegate 冲突了，自然就会报错，只要把 Appdelegate 上的 <code>@UIApplicationMain</code> 关键字删除就可以了。剩下的操作与 OC 中的是一样的。</p><p>具体的代码上传到 github 上了：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;ios事件机制&quot;&gt;iOS事件机制&lt;/span&gt;&lt;/h1&gt;&lt;p
      
    
    </summary>
    
      <category term="事件机制" scheme="http://superchun.cn/categories/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="事件拦截" scheme="http://superchun.cn/tags/%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/"/>
    
  </entry>
  
</feed>
