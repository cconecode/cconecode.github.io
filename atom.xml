<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悉达多｜Pain Maker</title>
  
  <subtitle>知也者，所以知也，而不必知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://superchun.cn/"/>
  <updated>2019-11-08T06:59:16.079Z</updated>
  <id>http://superchun.cn/</id>
  
  <author>
    <name>悉达多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac快捷键</title>
    <link href="http://superchun.cn/Mac%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
    <id>http://superchun.cn/Mac快捷键.html</id>
    <published>2019-11-08T06:26:02.000Z</published>
    <updated>2019-11-08T06:59:16.079Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="mac-快捷键的使用">Mac 快捷键的使用</span></h1><p>Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">官方文档</a>里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。</p><a id="more"></a><p>这些快捷键在 Mac 里面是通用的，也就意味着在几乎所有的有文本输入的地方，都可以用得上，一次学习，使用Anywhere :)。要熟悉掌握这些组合，还是要下一定功夫勤加练习的，不然右手又会不自觉地去触摸鼠标了。不过还是有一定技巧的，主要是掌握 <code>ctl</code>、<code>shift</code>、<code>fn</code> 的组合而已。</p><p><strong><em>（强烈建议大家将键盘上的大小写切换键改为 <code>ctl</code> 键，因为 <code>ctl</code> 的作用远比大小写切换重要多了，大小写切换完全可以使用 <code>shift</code> + 字母的方式进行输入，但大小写键在键盘上却占据了很重要的位置，<code>ctl</code>缩在角落瑟瑟发抖）。修改方法：系统设置 -&gt; 键盘 -&gt; 修饰键（在右下角）-&gt; 大写锁定键改为 Control</em></strong></p><h2><span id="光标移动">光标移动</span></h2><p><code>cmd</code> + <code>←</code>      移动至行首</p><p><code>cmd</code> + <code>→</code>      移动至行尾</p><p><code>fn</code> + <code>↓</code>        向下翻页</p><p><code>fn</code> + <code>↑</code>        向上翻页</p><p><code>option</code> + <code>←</code>    向前跳一个词</p><p><code>option</code> + <code>→</code>     向后跳一个词</p><p><code>ctl</code> + <code>p</code>     光标向上移动一行</p><p><code>ctl</code> + <code>n</code>     光标向下移动一行</p><p><code>ctl</code> + <code>b</code>     光标向前移动一个字母</p><p><code>ctl</code> + <code>f</code>      光标向后移动一个字母</p><p><code>ctl</code> + <code>e</code>      光标移动到行尾</p><p><code>ctl</code> + <code>a</code>      光标移动到行首</p><h2><span id="选取">选取</span></h2><p><code>option</code> + <code>shift</code> + <code>←</code>     向前选中一个单词</p><p><code>option</code> + <code>shift</code> + <code>→</code>     向后选中一个单词</p><p><code>cmd</code> + <code>shift</code> + <code>→</code>        从当前光标选中到行尾</p><p><code>cmd</code> + <code>shift</code> + <code>←</code>         从当前光标选中到行首</p><h2><span id="删除">删除</span></h2><p><code>fn</code> + <code>delete</code>      向后删除</p><p><code>option</code> + <code>delete</code>     向前删除一个单词</p><p><code>fn</code> + <code>option</code> + <code>delete</code>     向后删除一个单词</p><p><code>cmd</code> + <code>delete</code>     从当前光标删除到行首</p><p><code>fn</code> + <code>cmd</code> + <code>delete</code>     从当前光标删除到行尾</p><h2><span id="snap">Snap</span></h2><p>最后，也推荐给大家一个软件 <strong><code>Snap</code></strong>，在 AppStore 可以直接下载。这个软件的作用是绑定应用快捷键的，可以把对应的应用绑定成自己喜欢的快捷键，通过快捷键快速启动和切换应用，时间复杂度是 <em>O(1)</em>，远比用 <code>cmd</code> + <code>tab</code>（时间复杂度 <em>O(n)</em>）或者用鼠标点击（时间复杂度 <em>O(n^2)</em>）快多了</p><p>软件主界面长这样：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8qmrx1xtgj30nm0mq47h.jpg" alt="image-20191108144757647" style="zoom:50%;"></p><p>这个主要是设置默认快捷键的，比如这里设置了 <code>ctl</code> + <code>cmd</code>，那么你就可以通过 <code>ctl</code> + <code>cmd</code> + <code>1</code>  的快捷键来启动或者切换 Dock 上的第一个应用，<code>ctl</code> + <code>cmd</code> + <code>2</code> 启动或者切换第二个，以此类推。</p><p>上面这种方法不是很建议，因为需要记住应用在 Dock 上的位置或者自己手动排列 Dock 位置。还有另外一种方法就是 <code>Manual</code>，就是上面说的应用绑定快捷键，界面长这样：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8qmwfl0kaj30nm0mq0xz.jpg" alt="image-20191108145217899" style="zoom:50%;"></p><p>点击左下角就可以选择一个应用，然后输入对应的快捷键，后面就可以愉快的玩耍了 ^-^</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac-快捷键的使用&quot;&gt;&lt;a href=&quot;#Mac-快捷键的使用&quot; class=&quot;headerlink&quot; title=&quot;Mac 快捷键的使用&quot;&gt;&lt;/a&gt;Mac 快捷键的使用&lt;/h1&gt;&lt;p&gt;Mac 内置了很多对于文本操作的快捷键组合，在 Apple 的&lt;a href=&quot;https://support.apple.com/zh-cn/HT201236&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;里也给出了所有 Mac 操作的快捷键。熟悉这些快捷键可以让我们日常的使用和工作更有效率，双手不需要离开键盘去摸鼠标了。因为本身是个程序员，所以罗列了一些比较重要的快捷键组合，大部分都是关于文本操作的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈低语" scheme="http://superchun.cn/tags/%E6%9D%82%E8%B0%88%E4%BD%8E%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in Xcode11</title>
    <link href="http://superchun.cn/What-s-New-in-Xcode11.html"/>
    <id>http://superchun.cn/What-s-New-in-Xcode11.html</id>
    <published>2019-11-05T07:38:21.000Z</published>
    <updated>2019-11-05T12:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="wwdc19-whats-new-in-xcode11">WWDC19 - What’s New in Xcode11</span></h1><p>WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 <a href="https://developer.apple.com/videos/play/wwdc2019/401/" target="_blank" rel="noopener">WWDC 2019 Session 401</a>，顺便做一下记录。</p><a id="more"></a><p>首先，对 Xcode11 的整体改进做一个预览：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n98whgi4j30wc0ha7fe.jpg" alt="preview"></p><p>整体的改变还是挺多的，下面一一对改进的功能进行说明。</p><h2><span id="右上角功能键的改进">右上角功能键的改进</span></h2><p>首先，Xcode 11 改变的是右上角的按钮，Xcode 10 上是三个按钮，到了 11 已经变成了两个按钮：<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9nrz958j30ee03gq32.jpg" alt="image-20191105165729690" style="zoom:50%;">             <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9mwnaxgj30cc03iweo.jpg" alt="image-20191105165639942" style="zoom:50%;">     </p><p>原先的 Source Control Log 被移到了右侧栏里面：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9p9xusdj30ec05ktam.jpg" alt="image-20191105165856444" style="zoom:50%;">             <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9qc8ozdj30ee054dg7.jpg" alt="image-20191105165958024" style="zoom:50%;"></p><p>原先的比较常用的切换 Assitant Editor 和 Authors 一起并入到了 Editor Options 里面，并将 Editor Options 移到了每个独立的编辑窗口里面：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9wj9q5yj30ec05uwgf.jpg" alt="image-20191105170554608" style="zoom:50%;">              <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n9x9yx7vj30a00bgdlp.jpg" alt="image-20191105170637216" style="zoom:50%;">                   </p><p><em>上面 Xcode 11 的 Assistant 就是原先 Xcode 10 右上角的那两个圈圈</em></p><p>Editor Options 中同时新增了一个 Swift UI 的预览，当项目中使用到了 Swfit UI 的时候，可以预览 Swift UI 的效果</p><p>现在 Xcode 11 上面的两个按钮的功能变成了 Library 和 Code Review：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8na7koerqj30b203iwex.jpg" alt="image-20191105171631101"></p><p>Library 的主要功能是：选择 IB 控件、文档、代码块、图片资源以及颜色</p><p>Code Review 的主要功能是：比较同一源文件源码的改动</p><h2><span id="editor-splitting">Editor Splitting</span></h2><p>在 Xcode 11 里面，增加了一个 Editor Spliting 的功能，可以随时随地的增加一个 Editor：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8na1dqbffj307c0460sm.jpg" alt="image-20191105171034560"></p><p>Editor Spliting 默认的是往右边增加，按住 option 键再点击这个按钮，就可以在下面增加新的 Editor</p><p>可以通过按住 shift + option 并点击源文件，来管理 Editor，点击的源文件那个窗口会变成选中效果，可以用鼠标或者键盘方向键进行移动，移动完成后，点击键盘上的 return，原先选中的源文件就会插入或者移动到当前位置</p><h2><span id="minimap">Minimap</span></h2><p>Xcode 11 比较大的一个改动就是新增了 Minimap：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8napo7hbsj309w0lmjxt.jpg" alt="image-20191105173354397" style="zoom:50%;"></p><p>Minimap 主要是提供导航作用的，点击 Minimap 的任意位置，源码便会滚动到点击的地方。 当鼠标悬停在上面时，会显示当前的方法名：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8naszwn6tj30h40l0mxq.jpg" alt="image-20191105173706542" style="zoom:50%;"></p><p>同时按住 cmd 键的话，会显示当前所有的方法名：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nau5ip8rj30so0zi461.jpg" alt="image-20191105173813596" style="zoom:33%;"></p><p>当源码中有 warning 或者断点时，在 Minimap 中也会显示</p><p>源码中的 marks 在 Minimap 里可以直接看到：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nawlhq2ej307w0isglu.jpg" alt="image-20191105174034623" style="zoom:50%;"></p><p>当在源码中搜索关键字时，所有符合条件的在 Minimap 中会有选中效果：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nb0ed9c3j30860s8dgh.jpg" alt="image-20191105174413261" style="zoom:33%;"></p><h2><span id="源码-editor">源码 Editor</span></h2><p>Xcode 11 中通过 cmd + 右键点击方法名，可以给方法添加参数注释。新增了参数时，通过这个方法会自动拼接新的参数：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nbutwblij31he0b67en.jpg" alt="image-20191105181327456"></p><p>cmd + 右键点击参数，选择 Edit All in Scope，可以同时修改方法名、方法内、注释里面的参数名称：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nbwii6k1j314e08stb8.jpg" alt="image-20191105181504863"></p><p>当对源码进行了修改时，在 Editor 的左侧会出现一个蓝色条，点击这个蓝色条，可以选择 Show Change 和 Discard Change。Discard Change 的作用是撤销修改，Show Change 的作用是显示哪些地方进行了改动：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nc3aq6aqj30im06atdg.jpg" alt="image-20191105182136776" style="zoom:50%;"></p><p>除此之外，Xcode 11 还有着更好的自动补全、增加了新的 Theme，优化了一些细节体验</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WWDC19-What’s-New-in-Xcode11&quot;&gt;&lt;a href=&quot;#WWDC19-What’s-New-in-Xcode11&quot; class=&quot;headerlink&quot; title=&quot;WWDC19 - What’s New in Xcode11&quot;&gt;&lt;/a&gt;WWDC19 - What’s New in Xcode11&lt;/h1&gt;&lt;p&gt;WWDC 2019 已经过去快半年多了，Xcode 11 更新也有段时间了。用了一段时间之后，发现 Xcode 11 较之 Xcode 10 还是有许多地方不一样的，于是便看了 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2019/401/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2019 Session 401&lt;/a&gt;，顺便做一下记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://superchun.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Cordova in iOS</title>
    <link href="http://superchun.cn/Cordova.html"/>
    <id>http://superchun.cn/Cordova.html</id>
    <published>2016-09-07T16:00:00.000Z</published>
    <updated>2016-12-17T06:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。</p><h1><span id="环境搭建">环境搭建</span></h1><p>安装Cordova:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g cordova</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果提示错误，检查是否安装 Node.js</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建项目</span></span><br><span class="line"></span><br><span class="line">**创建工程项目：**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```ObjectiveC</span><br><span class="line">cordova create Cordova com.example.CordovaTest CordovaTest</span><br></pre></td></tr></table></figure><p>第一个参数为工程文件夹<br>第二个参数为应用的的 id 名，和 Xcode 中的 bundle Id 类似<br>第三个参数为工程名字</p><p><strong>添加 iOS 平台支持</strong></p><p>进入刚刚创建的工程目录下，执行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova platform add ios</span><br></pre></td></tr></table></figure><p>执行这个命令只出现光标没有反应的话，是因为网络原因。由于国内的网络环境，虽然的 npm 官方站点 <a href="http://www.npmjs.org/" target="_blank" rel="noopener">http://www.npmjs.org/</a> 并没有被墙，但是下载第三方依赖包的速度有时还是不理想，我们可以改用淘宝的 NPM 镜像。</p><p>打开 ~/.npmrc 文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.npmrc</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>保存退出，再执行命令就会发现很快就配置好了。</p><p>打开 platforms/ios 目录，就可以运行我们的创建的工程了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cordova 的前身是 PhoneGap，是一个 Hybrid 框架，可以让开发者使用HTML、Javascript、CSS开发跨平台的App。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;环境搭建&quot;&gt;环境搭建&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;安装Cordova:&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="Cordova" scheme="http://superchun.cn/categories/Cordova/"/>
    
    
      <category term="Cordova" scheme="http://superchun.cn/tags/Cordova/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL实战(一) - 简单图形绘制</title>
    <link href="http://superchun.cn/OpenGLES-2.html"/>
    <id>http://superchun.cn/OpenGLES-2.html</id>
    <published>2016-08-30T16:00:00.000Z</published>
    <updated>2016-12-17T12:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://parisdog.club/OpenGLES-1.html" target="_blank" rel="noopener">上一篇文章中</a>我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码+知识点+API解释的方式来写，同样的，如果有写的不好的地方，可以在评论中指出或者直接联系我（评论采用disqus，如果加载不出来，翻个墙试一下，联系方式见关于我）。</p><h1><span id="渲染屏幕">渲染屏幕====</span></h1><p>首先，将控制器继承自GLKViewController，并初始化一个GLKView，设置为它的View：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接把上篇文章的初始化方法copy过来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个上下文，并设置为当前上下文</span></span><br><span class="line">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">[EAGLContext setCurrentContext:context];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    使用代码初始化</span></span><br><span class="line"><span class="comment">//    GLKView *view = [GLKView alloc] initWithFrame:self.view.bounds context:context</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    使用Storyboard初始化</span></span><br><span class="line">GLKView *view = (GLKView *)<span class="keyword">self</span>.view;</span><br><span class="line">view.context = context; <span class="comment">// 关联上下文</span></span><br></pre></td></tr></table></figure><p>只需在GLKView的代理方法<code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect</code>中，调用<code>glClear</code>的系列函数就可以用OpenGL ES对屏幕进行渲染了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 清理屏幕的RGB颜色和alpha值，这里我们设置成了红色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来做一个酷炫的效果，让屏幕显示闪烁。当设置GLKViewController代理的时候，每一帧动画GLKViewController都会告诉我们，它会在1秒内多次调用<code>draw</code>方法，GLKViewController的代理中，我们可以在GLKViewController的代理方法<code>(void)glkViewControllerUpdate:(GLKViewController *)controller</code>方法来更新屏幕的颜色。</p><p>首先定义两个参数并初始化:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> redColorFloat; <span class="comment">// RGB中红色的色值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isIncreasing) <span class="built_in">BOOL</span> increasing; <span class="comment">// 判断是否增加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.increasing = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.redColorFloat = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>设定GLKViewController的刷新频率:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.preferredFramesPerSecond = <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>更新<code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect</code>中的代码，在GLKViewController的代理方法中更新屏幕颜色:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="keyword">self</span>.redColorFloat, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 清理屏幕的RGB颜色和alpha值</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 调用glClear来实际执行清理操作, 参数是一个缓冲区，缓冲区有多种格式，上篇文章有提及，现在我们执行的是颜色缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)glkViewControllerUpdate:(GLKViewController *)controller &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isIncreasing) &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat += <span class="number">1.0</span> * <span class="keyword">self</span>.timeSinceLastUpdate;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat -= <span class="number">1.0</span> * <span class="keyword">self</span>.timeSinceLastUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.redColorFloat &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">self</span>.increasing = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.redColorFloat &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.redColorFloat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.increasing = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了屏幕黑红闪烁效果，Demo可以在<a href="https://github.com/cconecode/OpenGLESTutorials/tree/master/Tutorial1-ScreenRendering" target="_blank" rel="noopener">这里</a>找到。</p><h1><span id="绘制图形">绘制图形</span></h1><p>现在我们来利用OpenGL ES绘制一个正方形。因为OpenGL ES只能渲染三角形，所以要用两个三角形来组成一个正方形。首先创建一组顶点数据和索引数据：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line">    GLfloat verties[] = &#123;</span><br><span class="line">        <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,  <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,   <span class="comment">// 前面为x, y, z, 后面为颜色</span></span><br><span class="line">        <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>,     <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line">        <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>,   <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,</span><br><span class="line">        <span class="number">-0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>,    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引数据</span></span><br><span class="line">    GLuint indecs[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>顶点数据中包括了顶点位置和对应的颜色，索引数据则是顶点数组的索引。然后我们需要向OpenGL ES发送数据和缓存数据：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">glGenBuffers(<span class="number">1</span>, &amp;vertBuffer); <span class="comment">// 创建缓冲区对象</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vertBuffer); <span class="comment">// 指定当前活动缓冲区对象</span></span><br><span class="line">                                           <span class="comment">// GL_ARRAY_BUFFER 坐标，颜色等</span></span><br><span class="line">                                           <span class="comment">// GL_ELEMENT_ARRAY_BUFFER 索引坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把顶点数据从 CPU 复制到 GPU</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(verties), verties, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// glBufferData(&lt;#GLenum target#&gt;, &lt;#GLsizeiptr size#&gt;, &lt;#const GLvoid *data#&gt;, &lt;#GLenum usage#&gt;)</span></span><br><span class="line"><span class="comment">// target: 可以是GL_ARRAY_BUFFER(顶点数据)，或者GL_ELEMENT_ARRAY_BUFFER(索引数据)</span></span><br><span class="line"><span class="comment">// size: 存储相关数据所需要的内存容量</span></span><br><span class="line"><span class="comment">// data: 用于初始化缓冲区对象，可以是指向某一块内存地址，也可以是NULL</span></span><br><span class="line"><span class="comment">//usage: 数据分配后如何读写，详细介绍见：http://parisdog.club/OpenGLES-2.html</span></span><br><span class="line"></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;indeBuffer); <span class="comment">// 索引数据</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indeBuffer);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indecs), indecs, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>关于 usage 的一些说明：</p><ul><li>GL_STREAM_DRAW: 数据只指定一次，并且最多只有几次作为绘图和指定图像函数的源数据</li><li>GL_STREAM_READ: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次由应用程序作为数据值使用</li><li>GL_STREAM_COPY: 数据从 OpenGL 缓冲区复制过来，并且最多只有几次作为绘图和指定图像函数的源数据</li><li>GL_STATIC_DRAW: 数据只指定一次，但是可以多次几次作为绘图和指定图像函数的源数据</li><li>GL_STATIC_READ:  数据从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用</li><li>GL_STATIC_COPY: 数据从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据</li><li>GL_DYNAMIC_DRAW: 数据可以多次指定，并且可以多次几次作为绘图和指定图像函数的源数据</li><li>GL_DYNAMIC_READ: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次由应用程序作为数据值使用 </li><li>GL_DYNAMIC_COPY: 数据可以多次从 OpenGL 缓冲区复制过来，并且可以多次几次作为绘图和指定图像函数的源数据</li></ul><p>在OpenGL ES2.0当中，无论渲染什么图形，都必须用到着色器。着色器是用类C语言-GLSL语言写的，如果想要自定义一个着色器，那么学习这门语言十分有必要。现在<code>GLKBaseEffect</code>这个类为我们提供了一些通用的着色器，在还没有掌握GLSL的情况下，我们目前可以使用它来帮我们实现效果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义和初始化一个GLKBaseEffect实例对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) GLKBaseEffect *effect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.effect = [[GLKBaseEffect alloc] init];</span><br><span class="line"><span class="comment">// 可以设置 effect 的一些属性，配置光，转化等</span></span><br></pre></td></tr></table></figure><p>最后在代理方法中启动着色器:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动着色器</span></span><br><span class="line">    [<span class="keyword">self</span>.effect prepareToDraw];</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="keyword">self</span>.count, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以看到最终的效果了：</p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/09/01/57c7eec495cab.jpg" width="200" alt="最终效果"><br></div><p>细心观察就会发现，我们想要的结果是一个正方形，现在出来的效果却是一个矩形，这是为什么呢？因为默认的，“Effect”的投影矩阵是一个单位矩阵，它不做任何变换，将场景（-1，-1，-1）到（1，1，1）的立文体范围的物体，投射到屏幕的X：-1，1，Y：-1，1。因此，当屏幕本身是非正方形时，正方形的物体将被拉伸，从而显示为矩形。所以我们要在<code>update</code> 中修改投影矩阵：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)update &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.view.bounds.size;</span><br><span class="line">    <span class="keyword">float</span> aspect = fabs(size.width / size.height);</span><br><span class="line">    </span><br><span class="line">    GLKMatrix4 projectMartix =    GLKMatrix4MakePerspective(GLKMathDegreesToRadians(<span class="number">130.0</span>), aspect, <span class="number">0.1</span>, <span class="number">10.0</span>);</span><br><span class="line">    <span class="comment">// 第一个参数代表视角</span></span><br><span class="line">    <span class="comment">// 第二个参数代表比例</span></span><br><span class="line">    <span class="comment">// 第三个参数代表近平面距离</span></span><br><span class="line">    <span class="comment">// 第四个参数代表远平面距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.effect.transform.projectionMatrix = projectMartix;</span><br><span class="line">    </span><br><span class="line">    GLKMatrix4 modelMatrix =     GLKMatrix4Translate(GLKMatrix4Identity, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>); <span class="comment">// 修改 Z 轴的距离</span></span><br><span class="line">    <span class="keyword">self</span>.effect.transform.modelviewMatrix = modelMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过这段代码就能得到我们想要的结果了：一个正方形（Demo 在<a href="https://github.com/cconecode/OpenGLESTutorials" target="_blank" rel="noopener">这里</a>）。在学习过程中，踩了很多坑，包括一开始的图像显示不出来，API 的意思也不明确。后来通过 Google 查阅相关资料，把一些 bug 解决了，同时也加深了对 OpenGL ES 的理解，学习到了很多的东西。上面的知识，在代码中我已经注释的很清楚了，如果有不懂的地方或者不正确的地方，欢迎指正交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;http://parisdog.club/OpenGLES-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章中&lt;/a&gt;我们学习了OpenGL ES的一些基本概念，剩下的知识我们在实战中不断的补充，后续的文章会以代码
      
    
    </summary>
    
      <category term="OpenGL ES" scheme="http://superchun.cn/categories/OpenGL-ES/"/>
    
    
      <category term="OpenGL ES" scheme="http://superchun.cn/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>初识 OpenGL ES</title>
    <link href="http://superchun.cn/OpenGLES-1.html"/>
    <id>http://superchun.cn/OpenGLES-1.html</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-08-30T15:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！</p><h1><span id="什么是opengl-es">什么是OpenGL ES</span></h1><blockquote><p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。</p><p>OpenGL ES是从OpenGL裁剪定制而来的，去除了glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性。经过多年发展，现在主要有两个版本，OpenGL ES 1.x针对固定管线硬件的，OpenGL ES 2.x针对可编程管线硬件。OpenGL ES 1.0是以OpenGL 1.3规范为基础的，OpenGL ES 1.1是以OpenGL 1.5规范为基础的，它们分别又支持common和common lite两种profile。lite profile只支持定点实数，而common profile既支持定点数又支持浮点数。OpenGL ES 2.0则是参照OpenGL 2.0规范定义的，common profile发布于2005-8，引入了对可编程管线的支持。OpenGL ES 3.0于2012年公布，加入了大量新特性。              - - - - 维基百科</p></blockquote><p>苹果官方文档中对于OpenGL ES的描述为：<br>OpenGL ES让App拥有了利用底层图形处理器的能力，iOS设备上的GPU可以执行复杂的2D和3D绘图，以及在最终图像上的每个像素的复杂着色计算。OpenGL ES是低级的、以硬件为中心的基于C的API，可以与iOS应用无缝集成。OpenGL ES规范没有定义窗口层，取而代之，当有任何绘图命令写入，主机操作系统必须定义一个方法来创建OpenGL ES<code>渲染上下文</code>，用来接受命令和帧缓冲。</p><h1><span id="opengl-es基本概念">OpenGL ES基本概念</span></h1><p><strong>坐标系</strong></p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/08/29/57c3f86c6f12c.jpg" width="150" height="显示高度" alt="OpenGL ES坐标系"><br></div><p>由于OpenGL ES可以用来绘制2D和3D图形，所以它的坐标是一个三维坐标，如果应用只涉及到2D，那么可以不考虑Z轴。</p><p><strong>纹理坐标</strong></p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/08/29/57c3fcfd8bfc2.jpg" width="150" alt="纹理坐标系"><br></div><p>一般OpenGL ES中的纹理坐标都是二维的，原点在左下角，与计算机中的图像坐标并不一致，二者的差别在于围绕横轴翻转180°。</p><p><strong>顶点数据&amp;&amp;索引</strong></p><p>顶点数据是一个数组，里面存的是顶点坐标。而索引则是顶点数组的对应的索引和串联关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line">GLFloat squareVertexData[] = &#123;</span><br><span class="line">    <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="comment">//x,y,z</span></span><br><span class="line">    <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">GLuint indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面顶点数组里面的一行就代表了坐标系里面的x,y,z三个坐标系，代表了一个顶点的位置，里面总共包含了4个点。索引数组则是顶点数据的索引，每一行代表一个连接关系，从0-1-2，从1-3-0。</p><h1><span id="eaglcontext">EAGLContext</span></h1><p>在使用OpenGL ES之前，必须初始化一个EAGLContext对象，并且将它设置为当前上下文</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化EAGLContext</span></span><br><span class="line">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为当前上下文</span></span><br><span class="line">[EAGLContext setCurrentContext:context];</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>每个线程都会维护一个当前上下文。</li><li>设置了一个新的上下文，EAGL会释放当前上下文，并且获取新的上下文。</li><li>当在同一个线程中转换两个或者更多的上下文时，在设置一个新的上下文作为当前上下文之前，需要调用<code>glFlush</code>函数，确保之前的一些命令可以及时传递给图像硬件设备。</li></ul><p>调用<code>glFlush</code>函数时需导入<code>OpenGLES/ES2/gl.h</code>框架。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glFlush()</span><br></pre></td></tr></table></figure><h1><span id="glkview">GLKView</span></h1><p><strong>GLKView介绍</strong></p><p>GLKView管理着OpenGL ES的基础，来提供绘制代码的地方。GLKView提供了基于OpenGL ES并等效于标准UIView的绘图生命周期。一个UIView实例自动配置图像上下文，所以<code>drawRect:</code>只需执行Quartz 2D绘图命令，GLKView实例自动配置本身，所以你的绘图方法只需执行OpenGL ES命令。GLKView通过维护一个保存着OpenGL ES绘图命令的帧缓冲对象来实现这一功能，一旦你的绘图方法完成，就会自动把结果呈现给Core Animation。</p><div align="center"><br><img src="http://ooo.0o0.ooo/2016/08/29/57c460e7a3f36.png" height="300" alt="通过GLKView渲染OpenGL ES内容"><br></div><p><strong>GLKView初始化方法</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">[EAGLContext setCurrentContext:context];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用代码初始化</span></span><br><span class="line"><span class="comment">//  GLKView *view = [GLKView alloc] initWithFrame:self.view.bounds context:context</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    使用Storyboard初始化</span></span><br><span class="line">GLKView *view = (GLKView *)<span class="keyword">self</span>.view;</span><br><span class="line">view.context = context; <span class="comment">// 关联上下文</span></span><br><span class="line">    </span><br><span class="line">view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; <span class="comment">// 颜色缓冲区格式</span></span><br><span class="line">view.drawableDepthFormat = GLKViewDrawableDepthFormat24; <span class="comment">// 深度缓冲区格式</span></span><br><span class="line">view.drawableStencilFormat = GLKViewDrawableStencilFormat8; <span class="comment">// 模型缓冲区格式</span></span><br><span class="line">view.drawableMultisample = GLKViewDrawableMultisample4X; <span class="comment">// 允许多重采样 (多重采样主要用于反锯齿，只对多边形的边缘进行抗锯齿处理，资源消耗较小，最常见的反锯齿), 如果允许了多重采样，必须测试性能</span></span><br></pre></td></tr></table></figure><p><strong>GLKViewDelegate</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染场景代码</span></span><br><span class="line">- (<span class="keyword">void</span>)glkView:(GLKView *)view drawInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景数据变化</span></span><br><span class="line">- (<span class="keyword">void</span>)update &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLKView能够为OpenGL ES的绘制提供一个简单的界面，因为它管理着OpenGL ES渲染过程的部分标准：</p><ul><li>在调用绘图方法之前，视图：<ul><li>使<code>EAGLContext</code>为当前上下文</li><li>基于当前大小、比例因子和drawable属性（如果需要），创建帧缓冲对象和渲染缓冲区</li><li>将帧缓冲对象作为绘图命令的当前目标</li><li>设置OpenGL ES视图端口来匹配帧缓冲区大小</li></ul></li></ul><ul><li>绘图方法执行完后，视图：<ul><li>解析多重采样缓冲区（如果允许多重采样）</li><li>丢弃不需要的渲染缓冲区</li><li>将渲染缓冲区内容交给Core Animation缓存和显示</li></ul></li></ul><p>参考：<br>    <a href="https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1" target="_blank" rel="noopener">OpenGL ES Programming Guide for iOS </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在如今直播盛行，VR可能即将崛起的时代，OpenGL ES将会变得不可或缺。而OpenGL ES的学习曲线比较陡峭，所以写博文来记录学习过程，同时也希望能够帮助到一起想学习OpenGL ES的同学。由于能力尚浅，文中错误之处敬请指出，谢谢！&lt;/p&gt;
&lt;h1&gt;&lt;span id
      
    
    </summary>
    
      <category term="OpenGL ES" scheme="http://superchun.cn/categories/OpenGL-ES/"/>
    
    
      <category term="OpenGL ES" scheme="http://superchun.cn/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>iOS 事件拦截</title>
    <link href="http://superchun.cn/iOSEvent.html"/>
    <id>http://superchun.cn/iOSEvent.html</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2016-08-30T14:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。</p><h1><span id="ios事件机制">iOS事件机制</span></h1><p>iOS 中的事件分为三类：触摸事件（单点、多点、手势），传感器事件（加速传感器）和远程控制事件（<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html" target="_blank" rel="noopener">官方文档</a>），我们遇到情况是第一种也就是触摸事件的机制。</p><h2><span id="响应者链">响应者链</span></h2><p>当一个事件发生时，如果 first responder 不做处理，那么就会往下传递，如果下一个 responder 也不处理，那么就会继续传递到再下一个 responder 中，直到有一个 responder 处理或者没有 responder 了，如果没有 responder 处理这个事件，那么这个事件就被抛弃了。这些 responder 按照传递顺序连接起来就构成了响应者链。</p><p>iOS 中的响应者链：<br><img src="https://lh3.googleusercontent.com/-6DVPdEbo12A/V48oTEjGXfI/AAAAAAAAAAk/Vn_s04cJOlk/I/14689996896970.jpg" alt="苹果官方关于响应者链的描述"></p><p>从图中我们可以观察到，响应者链有以下几个特点：</p><ul><li><p>响应者链通常由 initial view 开始。</p></li><li><p>View 的 nextResponder 是它的 superView，如果 View 已经是它所在的 ViewController 中的 top view，那么 next responder 就是它所在的 ViewConTroller。</p></li><li><p>ViewController 如果有 superViewController，那么它的 nextResponder 就是它superViewController 最上面的 View。如果没有，那么它的 nextResponder 就是 Window。</p></li><li><p>Window 的 nextResponder 指向 Application，Application 是整个响应者链的顶层，它的 nextResponder 指向 nil。也就是说当事件传递到 Application 不被处理的话就会被抛弃了。</p></li></ul><p>由于 UI 的复杂性，整个响应者链是需要通过计算的，而计算顺序基本是与响应者链分发相反的。<code>无论哪种事件，都是系统本身先获得，再交给 UIApplication，由 UIApplication 决定交给谁去处理。</code> 关于事件分发的计算网上有很多文章，我就不赘述了。通过上述了解，我们可以得出一个结论：<code>如果我们需要拦截一个事件，最好的机会是在 UIApplication 里面。</code></p><h1><span id="需求具体实现">需求具体实现</span></h1><h2><span id="oc-版">OC 版</span></h2><p>根据上面的结论，我们目前的思路是继承 UIApplication，然后实现某一方法，进行事件拦截。根据查阅资料，重写 UIApplication 的 <code>sendEvent</code>方法可以达到目的，sendEvent介绍如下：</p><blockquote><p> <strong>sendEvent:</strong></p><p>Dispatches an event to the appropriate responder objects in the application.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure><p> <strong>Parameters</strong><br>event<br>A UIEvent object encapsulating the information about an event, including the touches involved.</p><p><strong>Discussion</strong><br>Subclasses may override this method to intercept incoming events for inspection and special dispatching. iOS calls this method for public events only.</p></blockquote><p>具体代码实现：</p><ol><li>新建一个继承 UIApplication 的 CTApplication，重写 sendEvent 方法，并判断是否为触摸事件：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CTApplication.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTApplication</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.type == <span class="built_in">UIEventTypeTouches</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[event.allTouches anyObject] phase] == <span class="built_in">UITouchPhaseBegan</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> [<span class="keyword">super</span> sendEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>2.由于需要检测用户多长时间没有点击屏幕，需要加一个定时器来进行倒计时，设置定时器的方法写在 CTApplication 的 init 方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CTApplication.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 不点击屏幕的时间 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> showTime = <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTApplication</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTApplication</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setTimer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setTimer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:showTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(showPicture) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showPicture &#123;</span><br><span class="line"><span class="comment">/** 在这里对广告轮播图进行设置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.再回到 sendEvent 方法中，如果该方法被触发了，那么让定时器失效，重新开始定时：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> sendEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (event.type == <span class="built_in">UIEventTypeTouches</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[event.allTouches anyObject] phase] == <span class="built_in">UITouchPhaseBegan</span>) &#123;</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">            [<span class="keyword">self</span> setTimer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.最后，在 main 函数中还要做对应的更改，替换 UIApplication 的调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CTApplication.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]), <span class="built_in">NSStringFromClass</span>([<span class="built_in">CTApplication</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="swift版">Swift版</span></h2><p>首先新建一个 UIApplication 的子类 CTApplication：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTApplication</span>: <span class="title">UIApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sendEvent</span><span class="params">(event: UIEvent)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.sendEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Swift 中没有 main 函数，所以需要自己手动建一个 main 函数，并设置入口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="type">UIApplicationMain</span>(<span class="type">Process</span>.argc, <span class="type">Process</span>.unsafeArgv, <span class="type">NSStringFromClass</span>(<span class="type">CTApplication</span>), <span class="type">NSStringFromClass</span>(<span class="type">AppDelegate</span>))</span><br></pre></td></tr></table></figure><p>这时，Appdelegate 中的<code>@UIApplicationMain</code>会报错。下面是苹果官方对于<code>@UIApplicationMain</code>关键字的描述：</p><blockquote><p>Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class.</p><p>If you do not use this attribute, supply a main.swift file with a main function that calls the UIApplicationMain(::<em>:) function. For example, if your app uses a custom subclass of UIApplication<br>as its principal class, call the UIApplicationMain(::</em>:) function instead of using this attribute.</p></blockquote><p>意思就是在类的最顶部声明 <code>@UIApplicationMain</code>，表示该类是Application 的 delegate，另外一种做法就是在 main.Swift 中调用 UIApplicationMain 函数，设置 delegate 和 application。而我们采取的是后面的办法，所以 delegate 冲突了，自然就会报错，只要把 Appdelegate 上的 <code>@UIApplicationMain</code> 关键字删除就可以了。剩下的操作与 OC 中的是一样的。</p><p>具体的代码上传到 github 上了：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中遇到一个需求，检测用户三分钟未点击屏幕，就出现广告轮播图。很自然的就联想到事件拦截了，然而之前对于 iOS 的事件机制并不是太过于了解，所以利用这次机会进行了深入学习。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;ios事件机制&quot;&gt;iOS事件机制&lt;/span&gt;&lt;/h1&gt;&lt;p
      
    
    </summary>
    
      <category term="事件机制" scheme="http://superchun.cn/categories/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="事件拦截" scheme="http://superchun.cn/tags/%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/"/>
    
  </entry>
  
</feed>
